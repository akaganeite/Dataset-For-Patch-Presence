diff --git a/MagickCore/accelerate.c b/MagickCore/accelerate.c
index 36a56caebcd..6286bd1e2fe 100644
--- a/MagickCore/accelerate.c
+++ b/MagickCore/accelerate.c
@@ -1016,7 +1016,7 @@ static MagickBooleanType ComputeContrastStretchImage(Image *image,
     ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed", image->filename);
  
   /* reset histogram */
-  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*sizeof(*histogram));
+  (void) memset(histogram,0,(MaxMap+1)*sizeof(*histogram));
 
   /*
   if (IsGrayImage(image,exception) != MagickFalse)
@@ -1219,7 +1219,7 @@ static MagickBooleanType ComputeContrastStretchImage(Image *image,
   /*
     Stretch the histogram to create the stretched image mapping.
   */
-  (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*sizeof(*stretch_map));
+  (void) memset(stretch_map,0,(MaxMap+1)*sizeof(*stretch_map));
   for (i=0; i <= (ssize_t) MaxMap; i++)
   {
     if ((image->channel_mask & RedChannel) != 0)
@@ -2333,7 +2333,7 @@ static MagickBooleanType ComputeEqualizeImage(Image *image,MagickCLEnv clEnv,
       ThrowBinaryException(ResourceLimitWarning,"MemoryAllocationFailed", image->filename);
 
   /* reset histogram */
-  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*sizeof(*histogram));
+  (void) memset(histogram,0,(MaxMap+1)*sizeof(*histogram));
 
   /* Create and initialize OpenCL buffers. */
   /* inputPixels = AcquirePixelCachePixels(image, &length, exception); */
@@ -2438,7 +2438,7 @@ static MagickBooleanType ComputeEqualizeImage(Image *image,MagickCLEnv clEnv,
   /*
     Integrate the histogram to get the equalization map.
   */
-  (void) ResetMagickMemory(&intensity,0,sizeof(intensity));
+  (void) memset(&intensity,0,sizeof(intensity));
   for (i=0; i <= (ssize_t) MaxMap; i++)
   {
     if ((image->channel_mask & SyncChannels) != 0)
@@ -2459,7 +2459,7 @@ static MagickBooleanType ComputeEqualizeImage(Image *image,MagickCLEnv clEnv,
   }
   black=map[0];
   white=map[(int) MaxMap];
-  (void) ResetMagickMemory(equalize_map,0,(MaxMap+1)*sizeof(*equalize_map));
+  (void) memset(equalize_map,0,(MaxMap+1)*sizeof(*equalize_map));
   for (i=0; i <= (ssize_t) MaxMap; i++)
   {
     if ((image->channel_mask & SyncChannels) != 0)
diff --git a/MagickCore/animate.c b/MagickCore/animate.c
index 765c1a95ec1..ae9441a6712 100644
--- a/MagickCore/animate.c
+++ b/MagickCore/animate.c
@@ -312,7 +312,7 @@ MagickExport MagickBooleanType AnimateImages(const ImageInfo *image_info,
     CatchException(exception);
   (void) XSetErrorHandler(XError);
   resource_database=XGetResourceDatabase(display,GetClientName());
-  (void) ResetMagickMemory(&resource_info,0,sizeof(XResourceInfo));
+  (void) memset(&resource_info,0,sizeof(XResourceInfo));
   XGetResourceInfo(image_info,resource_database,GetClientName(),&resource_info);
   if (image_info->page != (char *) NULL)
     resource_info.image_geometry=AcquireString(image_info->page);
diff --git a/MagickCore/annotate.c b/MagickCore/annotate.c
index 754b9c54eb1..4a63fb94f24 100644
--- a/MagickCore/annotate.c
+++ b/MagickCore/annotate.c
@@ -804,8 +804,8 @@ MagickExport MagickBooleanType GetMultilineTypeMetrics(Image *image,
     return(MagickFalse);
   annotate_info->render=MagickFalse;
   annotate_info->direction=UndefinedDirection;
-  (void) ResetMagickMemory(metrics,0,sizeof(*metrics));
-  (void) ResetMagickMemory(&extent,0,sizeof(extent));
+  (void) memset(metrics,0,sizeof(*metrics));
+  (void) memset(&extent,0,sizeof(extent));
   /*
     Find the widest of the text lines.
   */
@@ -900,7 +900,7 @@ MagickExport MagickBooleanType GetTypeMetrics(Image *image,
   annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   annotate_info->render=MagickFalse;
   annotate_info->direction=UndefinedDirection;
-  (void) ResetMagickMemory(metrics,0,sizeof(*metrics));
+  (void) memset(metrics,0,sizeof(*metrics));
   offset.x=0.0;
   offset.y=0.0;
   status=RenderType(image,annotate_info,&offset,metrics,exception);
diff --git a/MagickCore/blob.c b/MagickCore/blob.c
index f2b7287e0b0..fa36ebf9744 100644
--- a/MagickCore/blob.c
+++ b/MagickCore/blob.c
@@ -224,7 +224,7 @@ MagickExport CustomStreamInfo *AcquireCustomStreamInfo(
   magick_unreferenced(exception);
   custom_stream=(CustomStreamInfo *) AcquireCriticalMemory(
     sizeof(*custom_stream));
-  (void) ResetMagickMemory(custom_stream,0,sizeof(*custom_stream));
+  (void) memset(custom_stream,0,sizeof(*custom_stream));
   custom_stream->signature=MagickCoreSignature;
   return(custom_stream);
 }
@@ -1622,7 +1622,7 @@ MagickExport FILE *GetBlobFileHandle(const Image *image)
 MagickExport void GetBlobInfo(BlobInfo *blob_info)
 {
   assert(blob_info != (BlobInfo *) NULL);
-  (void) ResetMagickMemory(blob_info,0,sizeof(*blob_info));
+  (void) memset(blob_info,0,sizeof(*blob_info));
   blob_info->type=UndefinedStream;
   blob_info->quantum=(size_t) MagickMaxBlobExtent;
   blob_info->properties.st_mtime=time((time_t *) NULL);
@@ -3260,7 +3260,7 @@ MagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,
 
             blob_info->type=FileStream;
             (void) SetStreamBuffering(image_info,image);
-            (void) ResetMagickMemory(magick,0,sizeof(magick));
+            (void) memset(magick,0,sizeof(magick));
             count=fread(magick,1,sizeof(magick),blob_info->file_info.file);
             (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);
 #if defined(MAGICKCORE_POSIX_SUPPORT)
diff --git a/MagickCore/cache-view.c b/MagickCore/cache-view.c
index b4340e305f5..9de5ac79d66 100644
--- a/MagickCore/cache-view.c
+++ b/MagickCore/cache-view.c
@@ -164,7 +164,7 @@ MagickExport CacheView *AcquireVirtualCacheView(const Image *image,
     sizeof(*cache_view)));
   if (cache_view == (CacheView *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(cache_view,0,sizeof(*cache_view));
+  (void) memset(cache_view,0,sizeof(*cache_view));
   cache_view->image=ReferenceImage((Image *) image);
   cache_view->number_threads=GetOpenMPMaximumThreads();
   if (GetMagickResourceLimit(ThreadResource) > cache_view->number_threads)
@@ -216,7 +216,7 @@ MagickExport CacheView *CloneCacheView(const CacheView *cache_view)
     sizeof(*clone_view)));
   if (clone_view == (CacheView *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(clone_view,0,sizeof(*clone_view));
+  (void) memset(clone_view,0,sizeof(*clone_view));
   clone_view->image=ReferenceImage(cache_view->image);
   clone_view->number_threads=cache_view->number_threads;
   clone_view->nexus_info=AcquirePixelCacheNexus(cache_view->number_threads);
diff --git a/MagickCore/cache.c b/MagickCore/cache.c
index c941b9e9af2..eeebb851e5a 100644
--- a/MagickCore/cache.c
+++ b/MagickCore/cache.c
@@ -190,7 +190,7 @@ MagickPrivate Cache AcquirePixelCache(const size_t number_threads)
     *value;
 
   cache_info=(CacheInfo *) AcquireCriticalMemory(sizeof(*cache_info));
-  (void) ResetMagickMemory(cache_info,0,sizeof(*cache_info));
+  (void) memset(cache_info,0,sizeof(*cache_info));
   cache_info->type=UndefinedCache;
   cache_info->mode=IOMode;
   cache_info->disk_mode=IOMode;
@@ -265,7 +265,7 @@ MagickPrivate NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)
     sizeof(**nexus_info));
   if (nexus_info[0] == (NexusInfo *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(nexus_info[0],0,number_threads*sizeof(**nexus_info));
+  (void) memset(nexus_info[0],0,number_threads*sizeof(**nexus_info));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     nexus_info[i]=(&nexus_info[0][i]);
@@ -647,7 +647,7 @@ static MagickBooleanType ClonePixelCacheRepository(
       clone_nexus[id],exception);
     if (pixels == (Quantum *) NULL)
       continue;
-    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)
+    (void) memset(clone_nexus[id]->pixels,0,(size_t)
       clone_nexus[id]->length);
     if (optimize != MagickFalse)
       (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length*
@@ -2123,7 +2123,7 @@ MagickExport const char *GetPixelCacheFilename(const Image *image)
 MagickPrivate void GetPixelCacheMethods(CacheMethods *cache_methods)
 {
   assert(cache_methods != (CacheMethods *) NULL);
-  (void) ResetMagickMemory(cache_methods,0,sizeof(*cache_methods));
+  (void) memset(cache_methods,0,sizeof(*cache_methods));
   cache_methods->get_virtual_pixel_handler=GetVirtualPixelCache;
   cache_methods->get_virtual_pixels_handler=GetVirtualPixelsCache;
   cache_methods->get_virtual_metacontent_from_handler=
@@ -2716,7 +2716,7 @@ MagickPrivate const Quantum *GetVirtualPixelsFromNexus(const Image *image,
         "UnableToGetCacheNexus","`%s'",image->filename);
       return((const Quantum *) NULL);
     }
-  (void) ResetMagickMemory(virtual_pixel,0,cache_info->number_channels*
+  (void) memset(virtual_pixel,0,cache_info->number_channels*
     sizeof(*virtual_pixel));
   virtual_metacontent=(void *) NULL;
   switch (virtual_pixel_method)
@@ -2746,7 +2746,7 @@ MagickPrivate const Quantum *GetVirtualPixelsFromNexus(const Image *image,
                 CacheError,"UnableToGetCacheNexus","`%s'",image->filename);
               return((const Quantum *) NULL);
             }
-          (void) ResetMagickMemory(virtual_metacontent,0,
+          (void) memset(virtual_metacontent,0,
             cache_info->metacontent_extent);
         }
       switch (virtual_pixel_method)
@@ -4759,7 +4759,7 @@ static inline MagickBooleanType AcquireCacheNexusPixels(
       nexus_info->cache=(Quantum *) MagickAssumeAligned(AcquireAlignedMemory(1,
         (size_t) nexus_info->length));
       if (nexus_info->cache != (Quantum *) NULL)
-        (void) ResetMagickMemory(nexus_info->cache,0,(size_t)
+        (void) memset(nexus_info->cache,0,(size_t)
           nexus_info->length);
     }
   else
diff --git a/MagickCore/cipher.c b/MagickCore/cipher.c
index 92e0b4fbab3..6338b80abaf 100644
--- a/MagickCore/cipher.c
+++ b/MagickCore/cipher.c
@@ -192,7 +192,7 @@ static AESInfo *AcquireAESInfo(void)
     *aes_info;
 
   aes_info=(AESInfo *) AcquireCriticalMemory(sizeof(*aes_info));
-  (void) ResetMagickMemory(aes_info,0,sizeof(*aes_info));
+  (void) memset(aes_info,0,sizeof(*aes_info));
   aes_info->blocksize=AESBlocksize;
   aes_info->key=AcquireStringInfo(32);
   aes_info->encipher_key=(unsigned int *) AcquireQuantumMemory(60UL,sizeof(
@@ -482,8 +482,8 @@ static void EncipherAESBlock(AESInfo *aes_info,const unsigned char *plaintext,
     Reset registers.
   */
   alpha=0;
-  (void) ResetMagickMemory(key,0,sizeof(key));
-  (void) ResetMagickMemory(text,0,sizeof(text));
+  (void) memset(key,0,sizeof(key));
+  (void) memset(text,0,sizeof(text));
 }
 
 /*
@@ -636,7 +636,7 @@ MagickExport MagickBooleanType PasskeyDecipherImage(Image *image,
   UpdateSignature(signature_info,nonce);
   nonce=DestroyStringInfo(nonce);
   FinalizeSignature(signature_info);
-  (void) ResetMagickMemory(input_block,0,sizeof(input_block));
+  (void) memset(input_block,0,sizeof(input_block));
   digest=GetStringInfoDatum(GetSignatureDigest(signature_info));
   (void) CopyMagickMemory(input_block,digest,MagickMin(AESBlocksize,
     GetSignatureDigestsize(signature_info))*sizeof(*input_block));
@@ -706,8 +706,8 @@ MagickExport MagickBooleanType PasskeyDecipherImage(Image *image,
   */
   quantum_info=DestroyQuantumInfo(quantum_info);
   aes_info=DestroyAESInfo(aes_info);
-  (void) ResetMagickMemory(input_block,0,sizeof(input_block));
-  (void) ResetMagickMemory(output_block,0,sizeof(output_block));
+  (void) memset(input_block,0,sizeof(input_block));
+  (void) memset(output_block,0,sizeof(output_block));
   return(y == (ssize_t) image->rows ? MagickTrue : MagickFalse);
 }
 
@@ -856,7 +856,7 @@ MagickExport MagickBooleanType PasskeyEncipherImage(Image *image,
   (void) SetImageProperty(image,"cipher:mode","CTR",exception);
   (void) SetImageProperty(image,"cipher:nonce",signature,exception);
   signature=DestroyString(signature);
-  (void) ResetMagickMemory(input_block,0,sizeof(input_block));
+  (void) memset(input_block,0,sizeof(input_block));
   digest=GetStringInfoDatum(GetSignatureDigest(signature_info));
   (void) CopyMagickMemory(input_block,digest,MagickMin(AESBlocksize,
     GetSignatureDigestsize(signature_info))*sizeof(*input_block));
@@ -923,8 +923,8 @@ MagickExport MagickBooleanType PasskeyEncipherImage(Image *image,
   */
   quantum_info=DestroyQuantumInfo(quantum_info);
   aes_info=DestroyAESInfo(aes_info);
-  (void) ResetMagickMemory(input_block,0,sizeof(input_block));
-  (void) ResetMagickMemory(output_block,0,sizeof(output_block));
+  (void) memset(input_block,0,sizeof(input_block));
+  (void) memset(output_block,0,sizeof(output_block));
   return(y == (ssize_t) image->rows ? MagickTrue : MagickFalse);
 }
 
@@ -1029,7 +1029,7 @@ static void SetAESKey(AESInfo *aes_info,const StringInfo *key)
     Generate crypt key.
   */
   datum=GetStringInfoDatum(aes_info->key);
-  (void) ResetMagickMemory(datum,0,GetStringInfoLength(aes_info->key));
+  (void) memset(datum,0,GetStringInfoLength(aes_info->key));
   (void) CopyMagickMemory(datum,GetStringInfoDatum(key),MagickMin(
     GetStringInfoLength(key),GetStringInfoLength(aes_info->key)));
   for (i=0; i < n; i++)
@@ -1064,7 +1064,7 @@ static void SetAESKey(AESInfo *aes_info,const StringInfo *key)
     Reset registers.
   */
   datum=GetStringInfoDatum(aes_info->key);
-  (void) ResetMagickMemory(datum,0,GetStringInfoLength(aes_info->key));
+  (void) memset(datum,0,GetStringInfoLength(aes_info->key));
   alpha=0;
   beta=0;
 }
diff --git a/MagickCore/coder.c b/MagickCore/coder.c
index c544978496c..e9f30af600c 100644
--- a/MagickCore/coder.c
+++ b/MagickCore/coder.c
@@ -375,7 +375,7 @@ static SplayTreeInfo *AcquireCoderCache(const char *filename,
           ResourceLimitError,"MemoryAllocationFailed","`%s'",p->name);
         continue;
       }
-    (void) ResetMagickMemory(coder_info,0,sizeof(*coder_info));
+    (void) memset(coder_info,0,sizeof(*coder_info));
     coder_info->path=(char *) "[built-in]";
     coder_info->magick=(char *) p->magick;
     coder_info->name=(char *) p->name;
@@ -899,7 +899,7 @@ static MagickBooleanType LoadCoderCache(SplayTreeInfo *cache,const char *xml,
           Coder element.
         */
         coder_info=(CoderInfo *) AcquireCriticalMemory(sizeof(*coder_info));
-        (void) ResetMagickMemory(coder_info,0,sizeof(*coder_info));
+        (void) memset(coder_info,0,sizeof(*coder_info));
         coder_info->path=ConstantString(filename);
         coder_info->exempt=MagickFalse;
         coder_info->signature=MagickCoreSignature;
diff --git a/MagickCore/color.c b/MagickCore/color.c
index 60b36792e2b..ab38dd00ffa 100644
--- a/MagickCore/color.c
+++ b/MagickCore/color.c
@@ -881,7 +881,7 @@ static LinkedListInfo *AcquireColorCache(const char *filename,
           ResourceLimitError,"MemoryAllocationFailed","`%s'",p->name);
         continue;
       }
-    (void) ResetMagickMemory(color_info,0,sizeof(*color_info));
+    (void) memset(color_info,0,sizeof(*color_info));
     color_info->path=(char *) "[built-in]";
     color_info->name=(char *) p->name;
     GetPixelInfo((Image *) NULL,&color_info->color);
@@ -2101,7 +2101,7 @@ static MagickBooleanType LoadColorCache(LinkedListInfo *cache,const char *xml,
           Color element.
         */
         color_info=(ColorInfo *) AcquireCriticalMemory(sizeof(*color_info));
-        (void) ResetMagickMemory(color_info,0,sizeof(*color_info));
+        (void) memset(color_info,0,sizeof(*color_info));
         color_info->path=ConstantString(filename);
         color_info->exempt=MagickFalse;
         color_info->signature=MagickCoreSignature;
@@ -2266,7 +2266,7 @@ MagickExport MagickBooleanType QueryColorCompliance(const char *name,
       /*
         Parse hex color.
       */
-      (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
+      (void) memset(&pixel,0,sizeof(pixel));
       name++;
       for (n=0; isxdigit((int) ((unsigned char) name[n])) != 0; n++) ;
       if ((n % 3) == 0)
diff --git a/MagickCore/colorspace.c b/MagickCore/colorspace.c
index e7d64f5b879..376730a7a1d 100644
--- a/MagickCore/colorspace.c
+++ b/MagickCore/colorspace.c
@@ -823,7 +823,7 @@ static MagickBooleanType sRGBTransformImage(Image *image,
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
-  (void) ResetMagickMemory(&primary_info,0,sizeof(primary_info));
+  (void) memset(&primary_info,0,sizeof(primary_info));
   switch (colorspace)
   {
     case OHTAColorspace:
@@ -1151,7 +1151,7 @@ MagickExport MagickBooleanType SetImageColorspace(Image *image,
   image->colorspace=colorspace;
   image->rendering_intent=UndefinedIntent;
   image->gamma=1.000/2.200;
-  (void) ResetMagickMemory(&image->chromaticity,0,sizeof(image->chromaticity));
+  (void) memset(&image->chromaticity,0,sizeof(image->chromaticity));
   type=image->type;
   if (IsGrayColorspace(colorspace) != MagickFalse)
     {
diff --git a/MagickCore/compare.c b/MagickCore/compare.c
index 9b7be4417a5..4f385d7c8d7 100644
--- a/MagickCore/compare.c
+++ b/MagickCore/compare.c
@@ -415,7 +415,7 @@ static MagickBooleanType GetAbsoluteDistortion(const Image *image,
         status=MagickFalse;
         continue;
       }
-    (void) ResetMagickMemory(channel_distortion,0,sizeof(channel_distortion));
+    (void) memset(channel_distortion,0,sizeof(channel_distortion));
     for (x=0; x < (ssize_t) columns; x++)
     {
       double
@@ -533,7 +533,7 @@ static MagickBooleanType GetFuzzDistortion(const Image *image,
         status=MagickFalse;
         continue;
       }
-    (void) ResetMagickMemory(channel_distortion,0,sizeof(channel_distortion));
+    (void) memset(channel_distortion,0,sizeof(channel_distortion));
     for (x=0; x < (ssize_t) columns; x++)
     {
       double
@@ -648,7 +648,7 @@ static MagickBooleanType GetMeanAbsoluteDistortion(const Image *image,
         status=MagickFalse;
         continue;
       }
-    (void) ResetMagickMemory(channel_distortion,0,sizeof(channel_distortion));
+    (void) memset(channel_distortion,0,sizeof(channel_distortion));
     for (x=0; x < (ssize_t) columns; x++)
     {
       double
@@ -864,7 +864,7 @@ static MagickBooleanType GetMeanSquaredDistortion(const Image *image,
         status=MagickFalse;
         continue;
       }
-    (void) ResetMagickMemory(channel_distortion,0,sizeof(channel_distortion));
+    (void) memset(channel_distortion,0,sizeof(channel_distortion));
     for (x=0; x < (ssize_t) columns; x++)
     {
       double
@@ -1163,7 +1163,7 @@ static MagickBooleanType GetPeakAbsoluteDistortion(const Image *image,
         status=MagickFalse;
         continue;
       }
-    (void) ResetMagickMemory(channel_distortion,0,sizeof(channel_distortion));
+    (void) memset(channel_distortion,0,sizeof(channel_distortion));
     for (x=0; x < (ssize_t) columns; x++)
     {
       double
@@ -1445,7 +1445,7 @@ static MagickBooleanType GetStructuralSimilarityDistortion(const Image *image,
         status=MagickFalse;
         continue;
       }
-    (void) ResetMagickMemory(channel_distortion,0,sizeof(channel_distortion));
+    (void) memset(channel_distortion,0,sizeof(channel_distortion));
     for (x=0; x < (ssize_t) columns; x++)
     {
       double
@@ -1465,14 +1465,14 @@ static MagickBooleanType GetStructuralSimilarityDistortion(const Image *image,
       ssize_t
         v;
 
-      (void) ResetMagickMemory(x_pixel_mu,0,sizeof(x_pixel_mu));
-      (void) ResetMagickMemory(x_pixel_sigma_squared,0,
+      (void) memset(x_pixel_mu,0,sizeof(x_pixel_mu));
+      (void) memset(x_pixel_sigma_squared,0,
         sizeof(x_pixel_sigma_squared));
-      (void) ResetMagickMemory(xy_sigma,0,sizeof(xy_sigma));
-      (void) ResetMagickMemory(x_pixel_sigma_squared,0,
+      (void) memset(xy_sigma,0,sizeof(xy_sigma));
+      (void) memset(x_pixel_sigma_squared,0,
         sizeof(y_pixel_sigma_squared));
-      (void) ResetMagickMemory(y_pixel_mu,0,sizeof(y_pixel_mu));
-      (void) ResetMagickMemory(y_pixel_sigma_squared,0,
+      (void) memset(y_pixel_mu,0,sizeof(y_pixel_mu));
+      (void) memset(y_pixel_sigma_squared,0,
         sizeof(y_pixel_sigma_squared));
       k=kernel_info->values;
       reference=p;
@@ -1617,7 +1617,7 @@ MagickExport MagickBooleanType GetImageDistortion(Image *image,
     sizeof(*channel_distortion));
   if (channel_distortion == (double *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(channel_distortion,0,length*
+  (void) memset(channel_distortion,0,length*
     sizeof(*channel_distortion));
   switch (metric)
   {
@@ -1763,7 +1763,7 @@ MagickExport double *GetImageDistortions(Image *image,
     sizeof(*channel_distortion));
   if (channel_distortion == (double *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(channel_distortion,0,length*
+  (void) memset(channel_distortion,0,length*
     sizeof(*channel_distortion));
   status=MagickTrue;
   switch (metric)
diff --git a/MagickCore/compress.c b/MagickCore/compress.c
index f87e8a81a8b..4f71538ce11 100644
--- a/MagickCore/compress.c
+++ b/MagickCore/compress.c
@@ -270,7 +270,7 @@ MagickExport void Ascii85Initialize(Image *image)
     image->ascii85=(Ascii85Info *) AcquireMagickMemory(sizeof(*image->ascii85));
   if (image->ascii85 == (Ascii85Info *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(image->ascii85,0,sizeof(*image->ascii85));
+  (void) memset(image->ascii85,0,sizeof(*image->ascii85));
   image->ascii85->line_break=MaxLineExtent << 1;
   image->ascii85->offset=0;
 }
@@ -507,7 +507,7 @@ MagickExport MagickBooleanType HuffmanDecodeImage(Image *image,
     /*
       Initialize scanline to white.
     */
-    ResetMagickMemory(scanline,0,sizeof(*scanline)*image->columns);
+    memset(scanline,0,sizeof(*scanline)*image->columns);
     /*
       Decode Huffman encoded scanline.
     */
@@ -759,7 +759,7 @@ RestoreMSCWarning \
   if (scanline == (unsigned char *) NULL)
     ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
       inject_image->filename);
-  (void) ResetMagickMemory(scanline,0,width*sizeof(*scanline));
+  (void) memset(scanline,0,width*sizeof(*scanline));
   huffman_image=CloneImage(inject_image,0,0,MagickTrue,exception);
   if (huffman_image == (Image *) NULL)
     {
diff --git a/MagickCore/configure.c b/MagickCore/configure.c
index e02a0ef0687..cbb186f8370 100644
--- a/MagickCore/configure.c
+++ b/MagickCore/configure.c
@@ -204,7 +204,7 @@ static LinkedListInfo *AcquireConfigureCache(const char *filename,
           ResourceLimitError,"MemoryAllocationFailed","`%s'",p->name);
         continue;
       }
-    (void) ResetMagickMemory(configure_info,0,sizeof(*configure_info));
+    (void) memset(configure_info,0,sizeof(*configure_info));
     configure_info->path=(char *) "[built-in]";
     configure_info->name=(char *) p->name;
     configure_info->value=(char *) p->value;
@@ -1250,7 +1250,7 @@ static MagickBooleanType LoadConfigureCache(LinkedListInfo *cache,
         */
         configure_info=(ConfigureInfo *) AcquireCriticalMemory(
           sizeof(*configure_info));
-        (void) ResetMagickMemory(configure_info,0,sizeof(*configure_info));
+        (void) memset(configure_info,0,sizeof(*configure_info));
         configure_info->path=ConstantString(filename);
         configure_info->exempt=MagickFalse;
         configure_info->signature=MagickCoreSignature;
diff --git a/MagickCore/delegate.c b/MagickCore/delegate.c
index 7ecc62def7e..156bfba7294 100644
--- a/MagickCore/delegate.c
+++ b/MagickCore/delegate.c
@@ -2096,7 +2096,7 @@ static MagickBooleanType LoadDelegateCache(LinkedListInfo *cache,
         */
         delegate_info=(DelegateInfo *) AcquireCriticalMemory(
           sizeof(*delegate_info));
-        (void) ResetMagickMemory(delegate_info,0,sizeof(*delegate_info));
+        (void) memset(delegate_info,0,sizeof(*delegate_info));
         delegate_info->path=ConstantString(filename);
         delegate_info->thread_support=MagickTrue;
         delegate_info->signature=MagickCoreSignature;
diff --git a/MagickCore/display.c b/MagickCore/display.c
index c5293549542..745302b8b1f 100644
--- a/MagickCore/display.c
+++ b/MagickCore/display.c
@@ -1690,7 +1690,7 @@ MagickExport MagickBooleanType DisplayImages(const ImageInfo *image_info,
     CatchException(exception);
   (void) XSetErrorHandler(XError);
   resource_database=XGetResourceDatabase(display,GetClientName());
-  (void) ResetMagickMemory(&resource_info,0,sizeof(resource_info));
+  (void) memset(&resource_info,0,sizeof(resource_info));
   XGetResourceInfo(image_info,resource_database,GetClientName(),&resource_info);
   if (image_info->page != (char *) NULL)
     resource_info.image_geometry=AcquireString(image_info->page);
@@ -2931,7 +2931,7 @@ static MagickBooleanType XChopImage(Display *display,
   (void) XSelectInput(display,windows->image.id,
     windows->image.attributes.event_mask | PointerMotionMask);
   state=DefaultState;
-  (void) ResetMagickMemory(&segment_info,0,sizeof(segment_info));
+  (void) memset(&segment_info,0,sizeof(segment_info));
   do
   {
     if (windows->info.mapped != MagickFalse )
diff --git a/MagickCore/distort.c b/MagickCore/distort.c
index 3a137af007f..eb56d810119 100644
--- a/MagickCore/distort.c
+++ b/MagickCore/distort.c
@@ -1490,7 +1490,7 @@ MagickExport Image *DistortResizeImage(const Image *image,
     return((Image *) NULL);
   /* Do not short-circuit this resize if final image size is unchanged */
 
-  (void) ResetMagickMemory(distort_args,0,12*sizeof(double));
+  (void) memset(distort_args,0,12*sizeof(double));
   distort_args[4]=(double) image->columns;
   distort_args[6]=(double) columns;
   distort_args[9]=(double) image->rows;
diff --git a/MagickCore/distribute-cache.c b/MagickCore/distribute-cache.c
index 62d065738c8..42f0268ae54 100644
--- a/MagickCore/distribute-cache.c
+++ b/MagickCore/distribute-cache.c
@@ -214,7 +214,7 @@ static int ConnectPixelCacheServer(const char *hostname,const int port,
 #if defined(MAGICKCORE_WINDOWS_SUPPORT)
   NTInitializeWinsock(MagickTrue);
 #endif
-  (void) ResetMagickMemory(&hint,0,sizeof(hint));
+  (void) memset(&hint,0,sizeof(hint));
   hint.ai_family=AF_INET;
   hint.ai_socktype=SOCK_STREAM;
   hint.ai_flags=AI_PASSIVE;
@@ -341,7 +341,7 @@ MagickPrivate DistributeCacheInfo *AcquireDistributeCacheInfo(
   */
   server_info=(DistributeCacheInfo *) AcquireCriticalMemory(
     sizeof(*server_info));
-  (void) ResetMagickMemory(server_info,0,sizeof(*server_info));
+  (void) memset(server_info,0,sizeof(*server_info));
   server_info->signature=MagickCoreSignature;
   server_info->port=0;
   hostname=GetHostname(&server_info->port,exception);
@@ -930,7 +930,7 @@ MagickExport void DistributePixelCacheServer(const int port,
 #if defined(MAGICKCORE_WINDOWS_SUPPORT)
   NTInitializeWinsock(MagickFalse);
 #endif
-  (void) ResetMagickMemory(&hint,0,sizeof(hint));
+  (void) memset(&hint,0,sizeof(hint));
   hint.ai_family=AF_INET;
   hint.ai_socktype=SOCK_STREAM;
   hint.ai_flags=AI_PASSIVE;
diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index e9aa1b49e2a..3b04aec8b79 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -501,7 +501,7 @@ static PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info)
     sizeof(*polygon_info->edges));
   if (polygon_info->edges == (EdgeInfo *) NULL)
     return((PolygonInfo *) NULL);
-  (void) ResetMagickMemory(polygon_info->edges,0,number_edges*
+  (void) memset(polygon_info->edges,0,number_edges*
     sizeof(*polygon_info->edges));
   direction=0;
   edge=0;
@@ -509,8 +509,8 @@ static PolygonInfo *ConvertPathToPolygon(const PathInfo *path_info)
   n=0;
   number_points=0;
   points=(PointInfo *) NULL;
-  (void) ResetMagickMemory(&point,0,sizeof(point));
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
+  (void) memset(&point,0,sizeof(point));
+  (void) memset(&bounds,0,sizeof(bounds));
   for (i=0; path_info[i].code != EndCode; i++)
   {
     if ((path_info[i].code == MoveToCode) || (path_info[i].code == OpenCode) ||
@@ -1833,7 +1833,7 @@ MagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
-  (void) ResetMagickMemory(primitive_info,0,(size_t) number_points*
+  (void) memset(primitive_info,0,(size_t) number_points*
     sizeof(*primitive_info));
   graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   graphic_context[n]->viewbox=image->page;
@@ -3848,7 +3848,7 @@ static PolygonInfo **AcquirePolygonThreadSet(
     sizeof(*polygon_info));
   if (polygon_info == (PolygonInfo **) NULL)
     return((PolygonInfo **) NULL);
-  (void) ResetMagickMemory(polygon_info,0,number_threads*sizeof(*polygon_info));
+  (void) memset(polygon_info,0,number_threads*sizeof(*polygon_info));
   path_info=ConvertPrimitiveToPath(primitive_info);
   if (path_info == (PathInfo *) NULL)
     return(DestroyPolygonThreadSet(polygon_info));
@@ -5008,7 +5008,7 @@ MagickExport void GetAffineMatrix(AffineMatrix *affine_matrix)
 {
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(affine_matrix != (AffineMatrix *) NULL);
-  (void) ResetMagickMemory(affine_matrix,0,sizeof(*affine_matrix));
+  (void) memset(affine_matrix,0,sizeof(*affine_matrix));
   affine_matrix->sx=1.0;
   affine_matrix->sy=1.0;
 }
@@ -5056,7 +5056,7 @@ MagickExport void GetDrawInfo(const ImageInfo *image_info,DrawInfo *draw_info)
   */
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(draw_info != (DrawInfo *) NULL);
-  (void) ResetMagickMemory(draw_info,0,sizeof(*draw_info));
+  (void) memset(draw_info,0,sizeof(*draw_info));
   clone_info=CloneImageInfo(image_info);
   GetAffineMatrix(&draw_info->affine);
   exception=AcquireExceptionInfo();
diff --git a/MagickCore/effect.c b/MagickCore/effect.c
index 6f55e353a2d..153289430ba 100644
--- a/MagickCore/effect.c
+++ b/MagickCore/effect.c
@@ -210,7 +210,7 @@ MagickExport Image *AdaptiveBlurImage(const Image *image,const double radius,
       blur_image=DestroyImage(blur_image);
       ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(kernel,0,(size_t) width*sizeof(*kernel));
+  (void) memset(kernel,0,(size_t) width*sizeof(*kernel));
   for (i=0; i < (ssize_t) width; i+=2)
   {
     kernel[i]=(double *) MagickAssumeAligned(AcquireAlignedMemory(
@@ -531,7 +531,7 @@ MagickExport Image *AdaptiveSharpenImage(const Image *image,const double radius,
       sharp_image=DestroyImage(sharp_image);
       ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(kernel,0,(size_t) width*sizeof(*kernel));
+  (void) memset(kernel,0,(size_t) width*sizeof(*kernel));
   for (i=0; i < (ssize_t) width; i+=2)
   {
     kernel[i]=(double *) MagickAssumeAligned(AcquireAlignedMemory((size_t)
@@ -1076,7 +1076,7 @@ MagickExport Image *DespeckleImage(const Image *image,ExceptionInfo *exception)
       continue;
     if ((despeckle_traits & CopyPixelTrait) != 0)
       continue;
-    (void) ResetMagickMemory(pixels,0,length*sizeof(*pixels));
+    (void) memset(pixels,0,length*sizeof(*pixels));
     j=(ssize_t) image->columns+2;
     for (y=0; y < (ssize_t) image->rows; y++)
     {
@@ -1097,7 +1097,7 @@ MagickExport Image *DespeckleImage(const Image *image,ExceptionInfo *exception)
       }
       j++;
     }
-    (void) ResetMagickMemory(buffer,0,length*sizeof(*buffer));
+    (void) memset(buffer,0,length*sizeof(*buffer));
     for (k=0; k < 4; k++)
     {
       Hull(image,X[k],Y[k],image->columns,image->rows,1,pixels,buffer);
@@ -1207,7 +1207,7 @@ MagickExport Image *EdgeImage(const Image *image,const double radius,
   kernel_info=AcquireKernelInfo((const char *) NULL,exception);
   if (kernel_info == (KernelInfo *) NULL)
     ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(kernel_info,0,sizeof(*kernel_info));
+  (void) memset(kernel_info,0,sizeof(*kernel_info));
   kernel_info->width=width;
   kernel_info->height=width;
   kernel_info->x=(ssize_t) (kernel_info->width-1)/2;
@@ -3676,7 +3676,7 @@ MagickExport Image *SharpenImage(const Image *image,const double radius,
   kernel_info=AcquireKernelInfo((const char *) NULL,exception);
   if (kernel_info == (KernelInfo *) NULL)
     ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(kernel_info,0,sizeof(*kernel_info));
+  (void) memset(kernel_info,0,sizeof(*kernel_info));
   kernel_info->width=width;
   kernel_info->height=width;
   kernel_info->x=(ssize_t) (width-1)/2;
diff --git a/MagickCore/enhance.c b/MagickCore/enhance.c
index 3e22fbd872c..05b281e7a50 100644
--- a/MagickCore/enhance.c
+++ b/MagickCore/enhance.c
@@ -1076,7 +1076,7 @@ MagickExport MagickBooleanType ContrastStretchImage(Image *image,
     Form histogram.
   */
   status=MagickTrue;
-  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
+  (void) memset(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*histogram));
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
@@ -1146,7 +1146,7 @@ MagickExport MagickBooleanType ContrastStretchImage(Image *image,
   /*
     Stretch the histogram to create the stretched image mapping.
   */
-  (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*
+  (void) memset(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*stretch_map));
   for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
   {
@@ -1563,7 +1563,7 @@ MagickExport MagickBooleanType EqualizeImage(Image *image,
     Form histogram.
   */
   status=MagickTrue;
-  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
+  (void) memset(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*histogram));
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
@@ -1616,10 +1616,10 @@ MagickExport MagickBooleanType EqualizeImage(Image *image,
       map[GetPixelChannels(image)*j+i]=intensity;
     }
   }
-  (void) ResetMagickMemory(equalize_map,0,(MaxMap+1)*GetPixelChannels(image)*
+  (void) memset(equalize_map,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*equalize_map));
-  (void) ResetMagickMemory(black,0,sizeof(*black));
-  (void) ResetMagickMemory(white,0,sizeof(*white));
+  (void) memset(black,0,sizeof(*black));
+  (void) memset(white,0,sizeof(*white));
   for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
   {
     register ssize_t
@@ -1823,7 +1823,7 @@ MagickExport MagickBooleanType GammaImage(Image *image,const double gamma,
   if (gamma_map == (Quantum *) NULL)
     ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
       image->filename);
-  (void) ResetMagickMemory(gamma_map,0,(MaxMap+1)*sizeof(*gamma_map));
+  (void) memset(gamma_map,0,(MaxMap+1)*sizeof(*gamma_map));
   if (gamma != 0.0)
     for (i=0; i <= (ssize_t) MaxMap; i++)
       gamma_map[i]=ScaleMapToQuantum((double) (MaxMap*pow((double) i/
@@ -2879,7 +2879,7 @@ MagickExport MagickBooleanType LinearStretchImage(Image *image,
   /*
     Form histogram.
   */
-  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*sizeof(*histogram));
+  (void) memset(histogram,0,(MaxMap+1)*sizeof(*histogram));
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
   {
diff --git a/MagickCore/exception.c b/MagickCore/exception.c
index 9017f383aab..5c4e2a147ae 100644
--- a/MagickCore/exception.c
+++ b/MagickCore/exception.c
@@ -670,7 +670,7 @@ MagickExport void InheritException(ExceptionInfo *exception,
 MagickPrivate void InitializeExceptionInfo(ExceptionInfo *exception)
 {
   assert(exception != (ExceptionInfo *) NULL);
-  (void) ResetMagickMemory(exception,0,sizeof(*exception));
+  (void) memset(exception,0,sizeof(*exception));
   exception->severity=UndefinedException;
   exception->exceptions=(void *) NewLinkedList(0);
   exception->semaphore=AcquireSemaphoreInfo();
@@ -944,7 +944,7 @@ MagickExport MagickBooleanType ThrowException(ExceptionInfo *exception,
       UnlockSemaphoreInfo(exception->semaphore);
       ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(p,0,sizeof(*p));
+  (void) memset(p,0,sizeof(*p));
   p->severity=severity;
   if (reason != (const char *) NULL)
     p->reason=ConstantString(reason);
diff --git a/MagickCore/feature.c b/MagickCore/feature.c
index 6dda2b89cd9..e6fd778ee72 100644
--- a/MagickCore/feature.c
+++ b/MagickCore/feature.c
@@ -357,7 +357,7 @@ MagickExport Image *CannyEdgeImage(const Image *image,const double radius,
           { -1.0, -1.0 }
         };
 
-      (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
+      (void) memset(&pixel,0,sizeof(pixel));
       dx=0.0;
       dy=0.0;
       kernel_pixels=p;
@@ -679,7 +679,7 @@ MagickExport ChannelFeatures *GetImageFeatures(const Image *image,
     sizeof(*channel_features));
   if (channel_features == (ChannelFeatures *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(channel_features,0,length*
+  (void) memset(channel_features,0,length*
     sizeof(*channel_features));
   /*
     Form grays.
@@ -748,7 +748,7 @@ MagickExport ChannelFeatures *GetImageFeatures(const Image *image,
         channel_features);
       return(channel_features);
     }
-  (void) ResetMagickMemory(&gray,0,sizeof(gray));
+  (void) memset(&gray,0,sizeof(gray));
   for (i=0; i <= (ssize_t) MaxMap; i++)
   {
     if (grays[i].red != ~0U)
@@ -824,20 +824,20 @@ MagickExport ChannelFeatures *GetImageFeatures(const Image *image,
         ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
       return(channel_features);
     }
-  (void) ResetMagickMemory(&correlation,0,sizeof(correlation));
-  (void) ResetMagickMemory(density_x,0,2*(number_grays+1)*sizeof(*density_x));
-  (void) ResetMagickMemory(density_xy,0,2*(number_grays+1)*sizeof(*density_xy));
-  (void) ResetMagickMemory(density_y,0,2*(number_grays+1)*sizeof(*density_y));
-  (void) ResetMagickMemory(&mean,0,sizeof(mean));
-  (void) ResetMagickMemory(sum,0,number_grays*sizeof(*sum));
-  (void) ResetMagickMemory(&sum_squares,0,sizeof(sum_squares));
-  (void) ResetMagickMemory(density_xy,0,2*number_grays*sizeof(*density_xy));
-  (void) ResetMagickMemory(&entropy_x,0,sizeof(entropy_x));
-  (void) ResetMagickMemory(&entropy_xy,0,sizeof(entropy_xy));
-  (void) ResetMagickMemory(&entropy_xy1,0,sizeof(entropy_xy1));
-  (void) ResetMagickMemory(&entropy_xy2,0,sizeof(entropy_xy2));
-  (void) ResetMagickMemory(&entropy_y,0,sizeof(entropy_y));
-  (void) ResetMagickMemory(&variance,0,sizeof(variance));
+  (void) memset(&correlation,0,sizeof(correlation));
+  (void) memset(density_x,0,2*(number_grays+1)*sizeof(*density_x));
+  (void) memset(density_xy,0,2*(number_grays+1)*sizeof(*density_xy));
+  (void) memset(density_y,0,2*(number_grays+1)*sizeof(*density_y));
+  (void) memset(&mean,0,sizeof(mean));
+  (void) memset(sum,0,number_grays*sizeof(*sum));
+  (void) memset(&sum_squares,0,sizeof(sum_squares));
+  (void) memset(density_xy,0,2*number_grays*sizeof(*density_xy));
+  (void) memset(&entropy_x,0,sizeof(entropy_x));
+  (void) memset(&entropy_xy,0,sizeof(entropy_xy));
+  (void) memset(&entropy_xy1,0,sizeof(entropy_xy1));
+  (void) memset(&entropy_xy2,0,sizeof(entropy_xy2));
+  (void) memset(&entropy_y,0,sizeof(entropy_y));
+  (void) memset(&variance,0,sizeof(variance));
   for (i=0; i < (ssize_t) number_grays; i++)
   {
     cooccurrence[i]=(ChannelStatistics *) AcquireQuantumMemory(number_grays,
@@ -846,9 +846,9 @@ MagickExport ChannelFeatures *GetImageFeatures(const Image *image,
     if ((cooccurrence[i] == (ChannelStatistics *) NULL) ||
         (Q[i] == (ChannelStatistics *) NULL))
       break;
-    (void) ResetMagickMemory(cooccurrence[i],0,number_grays*
+    (void) memset(cooccurrence[i],0,number_grays*
       sizeof(**cooccurrence));
-    (void) ResetMagickMemory(Q[i],0,number_grays*sizeof(**Q));
+    (void) memset(Q[i],0,number_grays*sizeof(**Q));
   }
   if (i < (ssize_t) number_grays)
     {
@@ -1447,8 +1447,8 @@ MagickExport ChannelFeatures *GetImageFeatures(const Image *image,
   /*
     Compute more texture features.
   */
-  (void) ResetMagickMemory(&variance,0,sizeof(variance));
-  (void) ResetMagickMemory(&sum_squares,0,sizeof(sum_squares));
+  (void) memset(&variance,0,sizeof(variance));
+  (void) memset(&sum_squares,0,sizeof(sum_squares));
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static,4) shared(status) \
     magick_number_threads(image,image,number_grays,1)
@@ -1618,7 +1618,7 @@ MagickExport ChannelFeatures *GetImageFeatures(const Image *image,
       ChannelStatistics
         pixel;
 
-      (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
+      (void) memset(&pixel,0,sizeof(pixel));
       for (y=0; y < (ssize_t) number_grays; y++)
       {
         register ssize_t
diff --git a/MagickCore/fourier.c b/MagickCore/fourier.c
index e1354180deb..e2b25192e16 100644
--- a/MagickCore/fourier.c
+++ b/MagickCore/fourier.c
@@ -540,10 +540,10 @@ static MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,
       return(MagickFalse);
     }
   magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);
-  (void) ResetMagickMemory(magnitude_pixels,0,fourier_info->width*
+  (void) memset(magnitude_pixels,0,fourier_info->width*
     fourier_info->height*sizeof(*magnitude_pixels));
   phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);
-  (void) ResetMagickMemory(phase_pixels,0,fourier_info->width*
+  (void) memset(phase_pixels,0,fourier_info->width*
     fourier_info->height*sizeof(*phase_pixels));
   status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,
     magnitude,magnitude_pixels);
@@ -716,7 +716,7 @@ static MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,
       return(MagickFalse);
     }
   source_pixels=(double *) GetVirtualMemoryBlob(source_info);
-  ResetMagickMemory(source_pixels,0,fourier_info->width*fourier_info->height*
+  memset(source_pixels,0,fourier_info->width*fourier_info->height*
     sizeof(*source_pixels));
   i=0L;
   image_view=AcquireVirtualCacheView(image,exception);
diff --git a/MagickCore/fx.c b/MagickCore/fx.c
index 658a666b389..0ac170667f4 100644
--- a/MagickCore/fx.c
+++ b/MagickCore/fx.c
@@ -176,7 +176,7 @@ MagickPrivate FxInfo *AcquireFxInfo(const Image *images,const char *expression,
     i;
 
   fx_info=(FxInfo *) AcquireCriticalMemory(sizeof(*fx_info));
-  (void) ResetMagickMemory(fx_info,0,sizeof(*fx_info));
+  (void) memset(fx_info,0,sizeof(*fx_info));
   fx_info->exception=AcquireExceptionInfo();
   fx_info->images=images;
   fx_info->colors=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,
@@ -3071,7 +3071,7 @@ static FxInfo **AcquireFxThreadSet(const Image *image,const char *expression,
         ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
       return((FxInfo **) NULL);
     }
-  (void) ResetMagickMemory(fx_info,0,number_threads*sizeof(*fx_info));
+  (void) memset(fx_info,0,number_threads*sizeof(*fx_info));
   if (*expression != '@')
     fx_expression=ConstantString(expression);
   else
diff --git a/MagickCore/geometry.c b/MagickCore/geometry.c
index 794cf6adf3b..420f5874589 100644
--- a/MagickCore/geometry.c
+++ b/MagickCore/geometry.c
@@ -869,7 +869,7 @@ MagickExport MagickStatusType ParseGeometry(const char *geometry,
     Remove whitespaces meta characters from geometry specification.
   */
   assert(geometry_info != (GeometryInfo *) NULL);
-  (void) ResetMagickMemory(geometry_info,0,sizeof(geometry_info));
+  (void) memset(geometry_info,0,sizeof(*geometry_info));
   flags=NoValue;
   if ((geometry == (char *) NULL) || (*geometry == '\0'))
     return(flags);
@@ -1657,7 +1657,7 @@ MagickExport void SetGeometry(const Image *image,RectangleInfo *geometry)
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(geometry != (RectangleInfo *) NULL);
-  (void) ResetMagickMemory(geometry,0,sizeof(*geometry));
+  (void) memset(geometry,0,sizeof(*geometry));
   geometry->width=image->columns;
   geometry->height=image->rows;
 }
@@ -1688,5 +1688,5 @@ MagickExport void SetGeometryInfo(GeometryInfo *geometry_info)
 {
   assert(geometry_info != (GeometryInfo *) NULL);
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
-  (void) ResetMagickMemory(geometry_info,0,sizeof(*geometry_info));
+  (void) memset(geometry_info,0,sizeof(*geometry_info));
 }
diff --git a/MagickCore/histogram.c b/MagickCore/histogram.c
index a9c3e998ab3..e8cba5ccd78 100644
--- a/MagickCore/histogram.c
+++ b/MagickCore/histogram.c
@@ -487,7 +487,7 @@ static CubeInfo *GetCubeInfo(void)
   cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));
   if (cube_info == (CubeInfo *) NULL)
     return((CubeInfo *) NULL);
-  (void) ResetMagickMemory(cube_info,0,sizeof(*cube_info));
+  (void) memset(cube_info,0,sizeof(*cube_info));
   /*
     Initialize root node.
   */
@@ -605,7 +605,7 @@ static NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t level)
     }
   cube_info->free_nodes--;
   node_info=cube_info->node_info++;
-  (void) ResetMagickMemory(node_info,0,sizeof(*node_info));
+  (void) memset(node_info,0,sizeof(*node_info));
   node_info->level=level;
   return(node_info);
 }
diff --git a/MagickCore/identify.c b/MagickCore/identify.c
index 118d197fa8e..77d5ab1c231 100644
--- a/MagickCore/identify.c
+++ b/MagickCore/identify.c
@@ -148,7 +148,7 @@ static ChannelStatistics *GetLocationStatistics(const Image *image,
     MaxPixelChannels+1,sizeof(*channel_statistics));
   if (channel_statistics == (ChannelStatistics *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(channel_statistics,0,(MaxPixelChannels+1)*
+  (void) memset(channel_statistics,0,(MaxPixelChannels+1)*
     sizeof(*channel_statistics));
   for (i=0; i <= (ssize_t) MaxPixelChannels; i++)
   {
diff --git a/MagickCore/image-view.c b/MagickCore/image-view.c
index 434b6c92787..8c5eb831907 100644
--- a/MagickCore/image-view.c
+++ b/MagickCore/image-view.c
@@ -109,7 +109,7 @@ MagickExport ImageView *CloneImageView(const ImageView *image_view)
   assert(image_view != (ImageView *) NULL);
   assert(image_view->signature == MagickCoreSignature);
   clone_view=(ImageView *) AcquireCriticalMemory(sizeof(*clone_view));
-  (void) ResetMagickMemory(clone_view,0,sizeof(*clone_view));
+  (void) memset(clone_view,0,sizeof(*clone_view));
   clone_view->description=ConstantString(image_view->description);
   clone_view->extent=image_view->extent;
   clone_view->view=CloneCacheView(image_view->view);
@@ -720,7 +720,7 @@ MagickExport ImageView *NewImageView(Image *image,ExceptionInfo *exception)
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   image_view=(ImageView *) AcquireCriticalMemory(sizeof(*image_view));
-  (void) ResetMagickMemory(image_view,0,sizeof(*image_view));
+  (void) memset(image_view,0,sizeof(*image_view));
   image_view->description=ConstantString("ImageView");
   image_view->image=image;
   image_view->view=AcquireVirtualCacheView(image_view->image,exception);
@@ -774,7 +774,7 @@ MagickExport ImageView *NewImageViewRegion(Image *image,const ssize_t x,
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   image_view=(ImageView *) AcquireCriticalMemory(sizeof(*image_view));
-  (void) ResetMagickMemory(image_view,0,sizeof(*image_view));
+  (void) memset(image_view,0,sizeof(*image_view));
   image_view->description=ConstantString("ImageView");
   image_view->view=AcquireVirtualCacheView(image_view->image,exception);
   image_view->image=image;
diff --git a/MagickCore/image.c b/MagickCore/image.c
index 895d49eebf9..df6bf6697a6 100644
--- a/MagickCore/image.c
+++ b/MagickCore/image.c
@@ -168,7 +168,7 @@ MagickExport Image *AcquireImage(const ImageInfo *image_info,
   */
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   image=(Image *) AcquireCriticalMemory(sizeof(*image));
-  (void) ResetMagickMemory(image,0,sizeof(*image));
+  (void) memset(image,0,sizeof(*image));
   /*
     Initialize Image structure.
   */
@@ -237,7 +237,7 @@ MagickExport Image *AcquireImage(const ImageInfo *image_info,
       RectangleInfo
         geometry;
 
-      (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+      (void) memset(&geometry,0,sizeof(geometry));
       flags=ParseAbsoluteGeometry(image_info->extract,&geometry);
       if (((flags & XValue) != 0) || ((flags & YValue) != 0))
         {
@@ -825,7 +825,7 @@ MagickExport Image *CloneImage(const Image *image,const size_t columns,
       return((Image *) NULL);
     }
   clone_image=(Image *) AcquireCriticalMemory(sizeof(*clone_image));
-  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));
+  (void) memset(clone_image,0,sizeof(*clone_image));
   clone_image->signature=MagickCoreSignature;
   clone_image->storage_class=image->storage_class;
   clone_image->number_channels=image->number_channels;
@@ -1357,7 +1357,7 @@ MagickExport void GetImageInfo(ImageInfo *image_info)
   */
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(image_info != (ImageInfo *) NULL);
-  (void) ResetMagickMemory(image_info,0,sizeof(*image_info));
+  (void) memset(image_info,0,sizeof(*image_info));
   image_info->adjoin=MagickTrue;
   image_info->interlace=NoInterlace;
   image_info->channel=DefaultChannels;
@@ -2962,7 +2962,7 @@ MagickExport MagickBooleanType SetImageInfo(ImageInfo *image_info,
           image=DestroyImage(image);
           return(MagickFalse);
         }
-      (void) ResetMagickMemory(magick,0,magick_size);
+      (void) memset(magick,0,magick_size);
       count=ReadBlob(image,magick_size,magick);
       (void) SeekBlob(image,-((MagickOffsetType) count),SEEK_CUR);
       (void) CloseBlob(image);
diff --git a/MagickCore/linked-list.c b/MagickCore/linked-list.c
index a30c2f1d6b7..5d5a5f59035 100644
--- a/MagickCore/linked-list.c
+++ b/MagickCore/linked-list.c
@@ -716,7 +716,7 @@ MagickExport LinkedListInfo *NewLinkedList(const size_t capacity)
     *list_info;
 
   list_info=(LinkedListInfo *) AcquireCriticalMemory(sizeof(*list_info));
-  (void) ResetMagickMemory(list_info,0,sizeof(*list_info));
+  (void) memset(list_info,0,sizeof(*list_info));
   list_info->capacity=capacity == 0 ? (size_t) (~0) : capacity;
   list_info->elements=0;
   list_info->head=(ElementInfo *) NULL;
diff --git a/MagickCore/locale.c b/MagickCore/locale.c
index 61466fc5e8e..1b4afdc5f04 100644
--- a/MagickCore/locale.c
+++ b/MagickCore/locale.c
@@ -1325,7 +1325,7 @@ static MagickBooleanType LoadLocaleCache(SplayTreeInfo *cache,const char *xml,
         (void) CopyMagickString(message,p,MagickMin((size_t) (q-p+2),
           MagickLocaleExtent));
         locale_info=(LocaleInfo *) AcquireCriticalMemory(sizeof(*locale_info));
-        (void) ResetMagickMemory(locale_info,0,sizeof(*locale_info));
+        (void) memset(locale_info,0,sizeof(*locale_info));
         locale_info->path=ConstantString(filename);
         locale_info->tag=ConstantString(tag);
         locale_info->message=ConstantString(message);
diff --git a/MagickCore/log.c b/MagickCore/log.c
index 8f39713f428..57bc7ce37bb 100644
--- a/MagickCore/log.c
+++ b/MagickCore/log.c
@@ -311,7 +311,7 @@ static LinkedListInfo *AcquireLogCache(const char *filename,
           ResourceLimitError,"MemoryAllocationFailed","`%s'",p->filename);
         continue;
       }
-    (void) ResetMagickMemory(log_info,0,sizeof(*log_info));
+    (void) memset(log_info,0,sizeof(*log_info));
     log_info->path=ConstantString("[built-in]");
     GetTimerInfo((TimerInfo *) &log_info->timer);
     log_info->event_mask=p->event_mask;
@@ -1545,7 +1545,7 @@ static MagickBooleanType LoadLogCache(LinkedListInfo *cache,const char *xml,
           Allocate memory for the log list.
         */
         log_info=(LogInfo *) AcquireCriticalMemory(sizeof(*log_info));
-        (void) ResetMagickMemory(log_info,0,sizeof(*log_info));
+        (void) memset(log_info,0,sizeof(*log_info));
         log_info->path=ConstantString(filename);
         GetTimerInfo((TimerInfo *) &log_info->timer);
         log_info->signature=MagickCoreSignature;
diff --git a/MagickCore/magic.c b/MagickCore/magic.c
index 94e2fa21b4b..70eaa2ed244 100644
--- a/MagickCore/magic.c
+++ b/MagickCore/magic.c
@@ -318,7 +318,7 @@ static LinkedListInfo *AcquireMagicCache(const char *filename,
           ResourceLimitError,"MemoryAllocationFailed","`%s'",p->name);
         continue;
       }
-    (void) ResetMagickMemory(magic_info,0,sizeof(*magic_info));
+    (void) memset(magic_info,0,sizeof(*magic_info));
     magic_info->path=(char *) "[built-in]";
     magic_info->name=(char *) p->name;
     magic_info->offset=p->offset;
@@ -928,7 +928,7 @@ static MagickBooleanType LoadMagicCache(LinkedListInfo *cache,const char *xml,
           Magic element.
         */
         magic_info=(MagicInfo *) AcquireCriticalMemory(sizeof(*magic_info));
-        (void) ResetMagickMemory(magic_info,0,sizeof(*magic_info));
+        (void) memset(magic_info,0,sizeof(*magic_info));
         magic_info->path=ConstantString(filename);
         magic_info->exempt=MagickFalse;
         magic_info->signature=MagickCoreSignature;
diff --git a/MagickCore/magick.c b/MagickCore/magick.c
index 86dcc4b6902..3dec681a121 100644
--- a/MagickCore/magick.c
+++ b/MagickCore/magick.c
@@ -180,7 +180,7 @@ MagickExport MagickInfo *AcquireMagickInfo(const char *module,const char *name,
   assert(description != (const char *) NULL);
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",name);
   magick_info=(MagickInfo *) AcquireCriticalMemory(sizeof(*magick_info));
-  (void) ResetMagickMemory(magick_info,0,sizeof(*magick_info));
+  (void) memset(magick_info,0,sizeof(*magick_info));
   magick_info->module=ConstantString(module);
   magick_info->name=ConstantString(name);
   magick_info->description=ConstantString(description);
diff --git a/MagickCore/matrix.c b/MagickCore/matrix.c
index 74b9f33b07c..5574621f505 100644
--- a/MagickCore/matrix.c
+++ b/MagickCore/matrix.c
@@ -212,7 +212,7 @@ MagickExport MatrixInfo *AcquireMatrixInfo(const size_t columns,
   matrix_info=(MatrixInfo *) AcquireMagickMemory(sizeof(*matrix_info));
   if (matrix_info == (MatrixInfo *) NULL)
     return((MatrixInfo *) NULL);
-  (void) ResetMagickMemory(matrix_info,0,sizeof(*matrix_info));
+  (void) memset(matrix_info,0,sizeof(*matrix_info));
   matrix_info->signature=MagickCoreSignature;
   matrix_info->columns=columns;
   matrix_info->rows=rows;
@@ -520,9 +520,9 @@ MagickPrivate MagickBooleanType GaussJordanElimination(double **matrix,
         rows=(ssize_t *) RelinquishMagickMemory(rows);
       return(MagickFalse);
     }
-  (void) ResetMagickMemory(columns,0,rank*sizeof(*columns));
-  (void) ResetMagickMemory(rows,0,rank*sizeof(*rows));
-  (void) ResetMagickMemory(pivots,0,rank*sizeof(*pivots));
+  (void) memset(columns,0,rank*sizeof(*columns));
+  (void) memset(rows,0,rank*sizeof(*rows));
+  (void) memset(pivots,0,rank*sizeof(*pivots));
   column=0;
   row=0;
   for (i=0; i < (ssize_t) rank; i++)
@@ -990,7 +990,7 @@ MagickExport Image *MatrixToImage(const MatrixInfo *matrix_info,
 %
 %  NullMatrix() sets all elements of the matrix to zero.
 %
-%  The format of the ResetMagickMemory method is:
+%  The format of the memset method is:
 %
 %      MagickBooleanType *NullMatrix(MatrixInfo *matrix_info)
 %
@@ -1015,7 +1015,7 @@ MagickExport MagickBooleanType NullMatrix(MatrixInfo *matrix_info)
   assert(matrix_info->signature == MagickCoreSignature);
   if (matrix_info->type != DiskCache)
     {
-      (void) ResetMagickMemory(matrix_info->elements,0,(size_t)
+      (void) memset(matrix_info->elements,0,(size_t)
         matrix_info->length);
       return(MagickTrue);
     }
diff --git a/MagickCore/mime.c b/MagickCore/mime.c
index 0416bc03807..b375625411a 100644
--- a/MagickCore/mime.c
+++ b/MagickCore/mime.c
@@ -859,7 +859,7 @@ static MagickBooleanType LoadMimeCache(LinkedListInfo *cache,const char *xml,
       Process mime element.
     */
     mime_info=(MimeInfo *) AcquireCriticalMemory(sizeof(*mime_info));
-    (void) ResetMagickMemory(mime_info,0,sizeof(*mime_info));
+    (void) memset(mime_info,0,sizeof(*mime_info));
     mime_info->path=ConstantString(filename);
     mime_info->signature=MagickCoreSignature;
     attribute=GetXMLTreeAttribute(mime,"data-type");
diff --git a/MagickCore/module.c b/MagickCore/module.c
index 39721f4fb03..29cf5767209 100644
--- a/MagickCore/module.c
+++ b/MagickCore/module.c
@@ -142,7 +142,7 @@ MagickExport ModuleInfo *AcquireModuleInfo(const char *path,const char *tag)
     *module_info;
 
   module_info=(ModuleInfo *) AcquireCriticalMemory(sizeof(*module_info));
-  (void) ResetMagickMemory(module_info,0,sizeof(*module_info));
+  (void) memset(module_info,0,sizeof(*module_info));
   if (path != (const char *) NULL)
     module_info->path=ConstantString(path);
   if (tag != (const char *) NULL)
diff --git a/MagickCore/montage.c b/MagickCore/montage.c
index 5e8d647f75a..117b15ceddd 100644
--- a/MagickCore/montage.c
+++ b/MagickCore/montage.c
@@ -220,7 +220,7 @@ MagickExport void GetMontageInfo(const ImageInfo *image_info,
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   assert(montage_info != (MontageInfo *) NULL);
-  (void) ResetMagickMemory(montage_info,0,sizeof(*montage_info));
+  (void) memset(montage_info,0,sizeof(*montage_info));
   (void) CopyMagickString(montage_info->filename,image_info->filename,
     MagickPathExtent);
   montage_info->geometry=AcquireString(DefaultTileGeometry);
@@ -486,7 +486,7 @@ MagickExport Image *MontageImageList(const ImageInfo *image_info,
     }
   border_width=montage_info->border_width;
   bevel_width=0;
-  (void) ResetMagickMemory(&frame_info,0,sizeof(frame_info));
+  (void) memset(&frame_info,0,sizeof(frame_info));
   if (montage_info->frame != (char *) NULL)
     {
       char
diff --git a/MagickCore/morphology.c b/MagickCore/morphology.c
index 12b404ef994..bc521bdaf1d 100644
--- a/MagickCore/morphology.c
+++ b/MagickCore/morphology.c
@@ -238,7 +238,7 @@ static KernelInfo *ParseKernelArray(const char *kernel_string)
   kernel=(KernelInfo *) AcquireQuantumMemory(1,sizeof(*kernel));
   if (kernel == (KernelInfo *) NULL)
     return(kernel);
-  (void) ResetMagickMemory(kernel,0,sizeof(*kernel));
+  (void) memset(kernel,0,sizeof(*kernel));
   kernel->minimum = kernel->maximum = kernel->angle = 0.0;
   kernel->negative_range = kernel->positive_range = 0.0;
   kernel->type = UserDefinedKernel;
@@ -1017,7 +1017,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
       kernel=(KernelInfo *) AcquireMagickMemory(sizeof(*kernel));
       if (kernel == (KernelInfo *) NULL)
         return(kernel);
-      (void) ResetMagickMemory(kernel,0,sizeof(*kernel));
+      (void) memset(kernel,0,sizeof(*kernel));
       kernel->minimum = kernel->maximum = kernel->angle = 0.0;
       kernel->negative_range = kernel->positive_range = 0.0;
       kernel->type = type;
@@ -1081,7 +1081,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
                       kernel->values[i] = exp(-((double)(u*u+v*v))*A)*B;
               }
             else /* limiting case - a unity (normalized Dirac) kernel */
-              { (void) ResetMagickMemory(kernel->values,0, (size_t)
+              { (void) memset(kernel->values,0, (size_t)
                   kernel->width*kernel->height*sizeof(*kernel->values));
                 kernel->values[kernel->x+kernel->y*kernel->width] = 1.0;
               }
@@ -1113,7 +1113,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
                     }
               }
             else /* special case - generate a unity kernel */
-              { (void) ResetMagickMemory(kernel->values,0, (size_t)
+              { (void) memset(kernel->values,0, (size_t)
                   kernel->width*kernel->height*sizeof(*kernel->values));
                 kernel->values[kernel->x+kernel->y*kernel->width] = 1.0;
               }
@@ -1173,7 +1173,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
 
         /* initialize */
         v = (ssize_t) (kernel->width*KernelRank-1)/2; /* start/end points to fit range */
-        (void) ResetMagickMemory(kernel->values,0, (size_t)
+        (void) memset(kernel->values,0, (size_t)
           kernel->width*kernel->height*sizeof(*kernel->values));
         /* Calculate a Positive 1D Gaussian */
         if ( sigma > MagickEpsilon )
@@ -1199,7 +1199,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
               kernel->values[i] = exp(-((double)(u*u))*alpha)*beta;
           }
         else /* special case - generate a unity kernel */
-          { (void) ResetMagickMemory(kernel->values,0, (size_t)
+          { (void) memset(kernel->values,0, (size_t)
               kernel->width*kernel->height*sizeof(*kernel->values));
             kernel->values[kernel->x+kernel->y*kernel->width] = 1.0;
           }
@@ -1258,7 +1258,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
 #if 1
 #define KernelRank 3
             v = (ssize_t) kernel->width*KernelRank; /* start/end points */
-            (void) ResetMagickMemory(kernel->values,0, (size_t)
+            (void) memset(kernel->values,0, (size_t)
               kernel->width*sizeof(*kernel->values));
             sigma *= KernelRank;            /* simplify the loop expression */
             A = 1.0/(2.0*sigma*sigma);
@@ -1280,7 +1280,7 @@ MagickExport KernelInfo *AcquireKernelBuiltIn(const KernelInfoType type,
 #endif
           }
         else /* special case - generate a unity kernel */
-          { (void) ResetMagickMemory(kernel->values,0, (size_t)
+          { (void) memset(kernel->values,0, (size_t)
               kernel->width*kernel->height*sizeof(*kernel->values));
             kernel->values[kernel->x+kernel->y*kernel->width] = 1.0;
             kernel->positive_range = 1.0;
diff --git a/MagickCore/nt-base.c b/MagickCore/nt-base.c
index b4993d9c96b..ce2592730d4 100644
--- a/MagickCore/nt-base.c
+++ b/MagickCore/nt-base.c
@@ -1547,13 +1547,13 @@ MagickPrivate int NTGhostscriptLoadDLL(void)
       UnlockSemaphoreInfo(ghost_semaphore);
       return(FALSE);
     }
-  (void) ResetMagickMemory((void *) &nt_ghost_info,0,sizeof(NTGhostInfo));
+  (void) memset((void *) &nt_ghost_info,0,sizeof(NTGhostInfo));
   nt_ghost_info.delete_instance=(void (MagickDLLCall *)(gs_main_instance *)) (
     lt_dlsym(ghost_handle,"gsapi_delete_instance"));
   nt_ghost_info.new_instance=(int (MagickDLLCall *)(gs_main_instance **,
     void *)) (lt_dlsym(ghost_handle,"gsapi_new_instance"));
   nt_ghost_info.has_instance=MagickFalse;
-  (void) ResetMagickMemory((void *) &ghost_info,0,sizeof(GhostInfo));
+  (void) memset((void *) &ghost_info,0,sizeof(GhostInfo));
   ghost_info.delete_instance=NTGhostscriptDeleteInstance;
   ghost_info.exit=(int (MagickDLLCall *)(gs_main_instance*))
     lt_dlsym(ghost_handle,"gsapi_exit");
@@ -1600,7 +1600,7 @@ MagickPrivate void NTGhostscriptUnLoadDLL(void)
     {
       (void) lt_dlclose(ghost_handle);
       ghost_handle=(void *) NULL;
-      (void) ResetMagickMemory((void *) &ghost_info,0,sizeof(GhostInfo));
+      (void) memset((void *) &ghost_info,0,sizeof(GhostInfo));
     }
   UnlockSemaphoreInfo(ghost_semaphore);
   RelinquishSemaphoreInfo(&ghost_semaphore);
diff --git a/MagickCore/nt-feature.c b/MagickCore/nt-feature.c
index 05e3bf705dc..a8ca74ab5d3 100644
--- a/MagickCore/nt-feature.c
+++ b/MagickCore/nt-feature.c
@@ -377,7 +377,7 @@ MagickExport MagickBooleanType NTAcquireTypeCache(SplayTreeInfo *type_cache,
         *pos='\0'; /* Remove (TrueType) from string */
 
         type_info=(TypeInfo *) AcquireCriticalMemory(sizeof(*type_info));
-        (void) ResetMagickMemory(type_info,0,sizeof(TypeInfo));
+        (void) memset(type_info,0,sizeof(TypeInfo));
 
         type_info->path=ConstantString("Windows Fonts");
         type_info->signature=MagickCoreSignature;
@@ -598,7 +598,7 @@ MagickExport void *ImageToHBITMAP(Image *image,ExceptionInfo *exception)
   ssize_t
     y;
 
-  (void) ResetMagickMemory(&bitmap,0,sizeof(bitmap));
+  (void) memset(&bitmap,0,sizeof(bitmap));
   bitmap.bmType=0;
   bitmap.bmWidth=(LONG) image->columns;
   bitmap.bmHeight=(LONG) image->rows;
diff --git a/MagickCore/opencl.c b/MagickCore/opencl.c
index cd7bd866a42..4c9f371eee2 100644
--- a/MagickCore/opencl.c
+++ b/MagickCore/opencl.c
@@ -531,7 +531,7 @@ MagickPrivate MagickCLCacheInfo AcquireMagickCLCacheInfo(MagickCLDevice device,
     info;
 
   info=(MagickCLCacheInfo) AcquireCriticalMemory(sizeof(*info));
-  (void) ResetMagickMemory(info,0,sizeof(*info));
+  (void) memset(info,0,sizeof(*info));
   LockSemaphoreInfo(openCL_lock);
   device->requested++;
   UnlockSemaphoreInfo(openCL_lock);
@@ -575,7 +575,7 @@ static MagickCLDevice AcquireMagickCLDevice()
   device=(MagickCLDevice) AcquireMagickMemory(sizeof(*device));
   if (device != NULL)
   {
-    (void) ResetMagickMemory(device,0,sizeof(*device));
+    (void) memset(device,0,sizeof(*device));
     ActivateSemaphoreInfo(&device->lock);
     device->score=MAGICKCORE_OPENCL_UNDEFINED_SCORE;
     device->command_queues_index=-1;
@@ -610,7 +610,7 @@ static MagickCLEnv AcquireMagickCLEnv(void)
   clEnv=(MagickCLEnv) AcquireMagickMemory(sizeof(*clEnv));
   if (clEnv != (MagickCLEnv) NULL)
   {
-    (void) ResetMagickMemory(clEnv,0,sizeof(*clEnv));
+    (void) memset(clEnv,0,sizeof(*clEnv));
     ActivateSemaphoreInfo(&clEnv->lock);
     clEnv->cpu_score=MAGICKCORE_OPENCL_UNDEFINED_SCORE;
     clEnv->enabled=MagickTrue;
@@ -795,7 +795,7 @@ static void LoadOpenCLDeviceBenchmark(MagickCLEnv clEnv,const char *xml)
           sizeof(*device_benchmark));
         if (device_benchmark == (MagickCLDeviceBenchmark *) NULL)
           break;
-        (void) ResetMagickMemory(device_benchmark,0,sizeof(*device_benchmark));
+        (void) memset(device_benchmark,0,sizeof(*device_benchmark));
         device_benchmark->score=MAGICKCORE_OPENCL_UNDEFINED_SCORE;
         continue;
       }
@@ -2292,7 +2292,7 @@ static void LoadOpenCLDevices(MagickCLEnv clEnv)
       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);
       return;
     }
-  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*
+  (void) memset(clEnv->devices,0,clEnv->number_devices*
     sizeof(MagickCLDevice));
   devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,
     sizeof(cl_device_id));
@@ -2446,7 +2446,7 @@ static MagickBooleanType BindOpenCLFunctions()
 #ifdef MAGICKCORE_OPENCL_MACOSX
 #define BIND(X) openCL_library->X= &X;
 #else
-  (void) ResetMagickMemory(openCL_library,0,sizeof(MagickLibrary));
+  (void) memset(openCL_library,0,sizeof(MagickLibrary));
 #ifdef MAGICKCORE_WINDOWS_SUPPORT
   openCL_library->library=(void *)LoadLibraryA("OpenCL.dll");
 #else
@@ -2736,7 +2736,7 @@ MagickPrivate MagickBooleanType RecordProfileData(MagickCLDevice device,
   else
     {
       profile_record=AcquireMagickMemory(sizeof(*profile_record));
-      (void) ResetMagickMemory(profile_record,0,sizeof(*profile_record));
+      (void) memset(profile_record,0,sizeof(*profile_record));
       profile_record->kernel_name=name;
       device->profile_records=ResizeMagickMemory(device->profile_records,(i+2)*
         sizeof(*device->profile_records));
diff --git a/MagickCore/paint.c b/MagickCore/paint.c
index 05928fd0c2b..adbf4e5745b 100644
--- a/MagickCore/paint.c
+++ b/MagickCore/paint.c
@@ -673,7 +673,7 @@ static size_t **AcquireHistogramThreadSet(const size_t count)
   histogram=(size_t **) AcquireQuantumMemory(number_threads,sizeof(*histogram));
   if (histogram == (size_t **) NULL)
     return((size_t **) NULL);
-  (void) ResetMagickMemory(histogram,0,number_threads*sizeof(*histogram));
+  (void) memset(histogram,0,number_threads*sizeof(*histogram));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     histogram[i]=(size_t *) AcquireQuantumMemory(count,sizeof(**histogram));
@@ -804,7 +804,7 @@ MagickExport Image *OilPaintImage(const Image *image,const double radius,
       k=0;
       j=0;
       count=0;
-      (void) ResetMagickMemory(histogram,0,NumberPaintBins* sizeof(*histogram));
+      (void) memset(histogram,0,NumberPaintBins* sizeof(*histogram));
       for (v=0; v < (ssize_t) width; v++)
       {
         for (u=0; u < (ssize_t) width; u++)
diff --git a/MagickCore/pixel.c b/MagickCore/pixel.c
index 253a42d2102..7edffd930f2 100644
--- a/MagickCore/pixel.c
+++ b/MagickCore/pixel.c
@@ -102,7 +102,7 @@ MagickExport PixelChannelMap *AcquirePixelChannelMap(void)
     sizeof(*channel_map));
   if (channel_map == (PixelChannelMap *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(channel_map,0,MaxPixelChannels*sizeof(*channel_map));
+  (void) memset(channel_map,0,MaxPixelChannels*sizeof(*channel_map));
   for (i=0; i < MaxPixelChannels; i++)
     channel_map[i].channel=(PixelChannel) i;
   return(channel_map);
@@ -4338,7 +4338,7 @@ MagickExport void InitializePixelChannelMap(Image *image)
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
-  (void) ResetMagickMemory(image->channel_map,0,MaxPixelChannels*
+  (void) memset(image->channel_map,0,MaxPixelChannels*
     sizeof(*image->channel_map));
   trait=UpdatePixelTrait;
   if (image->alpha_trait != UndefinedPixelTrait)
@@ -5507,7 +5507,7 @@ MagickExport MagickBooleanType InterpolatePixelInfo(const Image *image,
   if (interpolate == UndefinedInterpolatePixel)
     interpolate=image->interpolate;
   GetPixelInfoPixel(image,(const Quantum *) NULL,pixel);
-  (void) ResetMagickMemory(&pixels,0,sizeof(pixels));
+  (void) memset(&pixels,0,sizeof(pixels));
   switch (interpolate)
   {
     case AverageInterpolatePixel:  /* nearest 4 neighbours */
diff --git a/MagickCore/policy.c b/MagickCore/policy.c
index 29ae0df55fe..1c47c746f6f 100644
--- a/MagickCore/policy.c
+++ b/MagickCore/policy.c
@@ -225,7 +225,7 @@ static LinkedListInfo *AcquirePolicyCache(const char *filename,
           ResourceLimitError,"MemoryAllocationFailed","`%s'",p->name);
         continue;
       }
-    (void) ResetMagickMemory(policy_info,0,sizeof(*policy_info));
+    (void) memset(policy_info,0,sizeof(*policy_info));
     policy_info->path=(char *) "[built-in]";
     policy_info->domain=p->domain;
     policy_info->rights=p->rights;
@@ -869,7 +869,7 @@ static MagickBooleanType LoadPolicyCache(LinkedListInfo *cache,const char *xml,
           Policy element.
         */
         policy_info=(PolicyInfo *) AcquireCriticalMemory(sizeof(*policy_info));
-        (void) ResetMagickMemory(policy_info,0,sizeof(*policy_info));
+        (void) memset(policy_info,0,sizeof(*policy_info));
         policy_info->path=ConstantString(filename);
         policy_info->exempt=MagickFalse;
         policy_info->signature=MagickCoreSignature;
@@ -1157,7 +1157,7 @@ static MagickBooleanType SetPolicyValue(const PolicyDomain domain,
   else
     {
       p=(PolicyInfo *) AcquireCriticalMemory(sizeof(*p));
-      (void) ResetMagickMemory(p,0,sizeof(*p));
+      (void) memset(p,0,sizeof(*p));
       p->exempt=MagickFalse;
       p->signature=MagickCoreSignature;
       p->domain=domain;
diff --git a/MagickCore/profile.c b/MagickCore/profile.c
index f9257ea58a5..c4b8cbf179c 100644
--- a/MagickCore/profile.c
+++ b/MagickCore/profile.c
@@ -366,7 +366,7 @@ static double **AcquirePixelThreadSet(const size_t columns,
   pixels=(double **) AcquireQuantumMemory(number_threads,sizeof(*pixels));
   if (pixels == (double **) NULL)
     return((double **) NULL);
-  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));
+  (void) memset(pixels,0,number_threads*sizeof(*pixels));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     pixels[i]=(double *) AcquireQuantumMemory(columns,channels*
@@ -409,7 +409,7 @@ static cmsHTRANSFORM *AcquireTransformThreadSet(Image *image,
     sizeof(*transform));
   if (transform == (cmsHTRANSFORM *) NULL)
     return((cmsHTRANSFORM *) NULL);
-  (void) ResetMagickMemory(transform,0,number_threads*sizeof(*transform));
+  (void) memset(transform,0,number_threads*sizeof(*transform));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     transform[i]=cmsCreateTransformTHR((cmsContext) image,source_profile,
diff --git a/MagickCore/property.c b/MagickCore/property.c
index 3b50b60d160..ea1320a04f0 100644
--- a/MagickCore/property.c
+++ b/MagickCore/property.c
@@ -1899,9 +1899,9 @@ static char *TracePSClippath(const unsigned char *blob,size_t length)
     The clipping path format is defined in "Adobe Photoshop File Formats
     Specification" version 6.0 downloadable from adobe.com.
   */
-  (void) ResetMagickMemory(point,0,sizeof(point));
-  (void) ResetMagickMemory(first,0,sizeof(first));
-  (void) ResetMagickMemory(last,0,sizeof(last));
+  (void) memset(point,0,sizeof(point));
+  (void) memset(first,0,sizeof(first));
+  (void) memset(last,0,sizeof(last));
   knot_count=0;
   in_subpath=MagickFalse;
   while (length > 0)
@@ -2091,9 +2091,9 @@ static char *TraceSVGClippath(const unsigned char *blob,size_t length,
     "stroke-width:0;stroke-antialiasing:false\" d=\"\n"),(double) columns,
     (double) rows);
   (void) ConcatenateString(&path,message);
-  (void) ResetMagickMemory(point,0,sizeof(point));
-  (void) ResetMagickMemory(first,0,sizeof(first));
-  (void) ResetMagickMemory(last,0,sizeof(last));
+  (void) memset(point,0,sizeof(point));
+  (void) memset(first,0,sizeof(first));
+  (void) memset(last,0,sizeof(last));
   knot_count=0;
   in_subpath=MagickFalse;
   while (length != 0)
diff --git a/MagickCore/quantize.c b/MagickCore/quantize.c
index 86305fe71ea..3e3ddb9c32d 100644
--- a/MagickCore/quantize.c
+++ b/MagickCore/quantize.c
@@ -1452,7 +1452,7 @@ static DoublePixelPacket **AcquirePixelThreadSet(const size_t count)
     sizeof(*pixels));
   if (pixels == (DoublePixelPacket **) NULL)
     return((DoublePixelPacket **) NULL);
-  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));
+  (void) memset(pixels,0,number_threads*sizeof(*pixels));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     pixels[i]=(DoublePixelPacket *) AcquireQuantumMemory(count,2*
@@ -1941,7 +1941,7 @@ static MagickBooleanType DitherImage(Image *image,CubeInfo *cube_info,
   /*
     Distribute quantization error along a Hilbert curve.
   */
-  (void) ResetMagickMemory(cube_info->error,0,ErrorQueueLength*
+  (void) memset(cube_info->error,0,ErrorQueueLength*
     sizeof(*cube_info->error));
   cube_info->x=0;
   cube_info->y=0;
@@ -2016,7 +2016,7 @@ static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,
   cube_info=(CubeInfo *) AcquireMagickMemory(sizeof(*cube_info));
   if (cube_info == (CubeInfo *) NULL)
     return((CubeInfo *) NULL);
-  (void) ResetMagickMemory(cube_info,0,sizeof(*cube_info));
+  (void) memset(cube_info,0,sizeof(*cube_info));
   cube_info->depth=depth;
   if (cube_info->depth > MaxTreeDepth)
     cube_info->depth=MaxTreeDepth;
@@ -2044,7 +2044,7 @@ static CubeInfo *GetCubeInfo(const QuantizeInfo *quantize_info,
   /*
     Initialize color cache.
   */
-  (void) ResetMagickMemory(cube_info->cache,(-1),sizeof(*cube_info->cache)*
+  (void) memset(cube_info->cache,(-1),sizeof(*cube_info->cache)*
     length);
   /*
     Distribute weights along a curve of exponential decay.
@@ -2128,7 +2128,7 @@ static NodeInfo *GetNodeInfo(CubeInfo *cube_info,const size_t id,
   cube_info->nodes++;
   cube_info->free_nodes--;
   node_info=cube_info->next_node++;
-  (void) ResetMagickMemory(node_info,0,sizeof(*node_info));
+  (void) memset(node_info,0,sizeof(*node_info));
   node_info->parent=parent;
   node_info->id=id;
   node_info->level=level;
@@ -2203,7 +2203,7 @@ MagickExport MagickBooleanType GetImageQuantizeError(Image *image,
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   image->total_colors=GetNumberColors(image,(FILE *) NULL,exception);
-  (void) ResetMagickMemory(&image->error,0,sizeof(image->error));
+  (void) memset(&image->error,0,sizeof(image->error));
   if (image->storage_class == DirectClass)
     return(MagickTrue);
   alpha=1.0;
@@ -2287,7 +2287,7 @@ MagickExport void GetQuantizeInfo(QuantizeInfo *quantize_info)
 {
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(quantize_info != (QuantizeInfo *) NULL);
-  (void) ResetMagickMemory(quantize_info,0,sizeof(*quantize_info));
+  (void) memset(quantize_info,0,sizeof(*quantize_info));
   quantize_info->number_colors=256;
   quantize_info->dither_method=RiemersmaDitherMethod;
   quantize_info->colorspace=UndefinedColorspace;
@@ -3329,7 +3329,7 @@ static MagickBooleanType SetGrayscaleImage(Image *image,
       image->filename);
   if (image->storage_class != PseudoClass)
     {
-      (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*
+      (void) memset(colormap_index,(-1),MaxColormapSize*
         sizeof(*colormap_index));
       if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)
         {
diff --git a/MagickCore/quantum-export.c b/MagickCore/quantum-export.c
index b5e76e85ff4..8c42f4dc860 100644
--- a/MagickCore/quantum-export.c
+++ b/MagickCore/quantum-export.c
@@ -119,7 +119,7 @@ static inline unsigned char *PopDoublePixel(QuantumInfo *quantum_info,
   unsigned char
     quantum[8];
 
-  (void) ResetMagickMemory(quantum,0,sizeof(quantum));
+  (void) memset(quantum,0,sizeof(quantum));
   p=(double *) quantum;
   *p=(double) (pixel*quantum_info->state.inverse_scale+quantum_info->minimum);
   if (quantum_info->endian == LSBEndian)
@@ -154,7 +154,7 @@ static inline unsigned char *PopFloatPixel(QuantumInfo *quantum_info,
   unsigned char
     quantum[4];
 
-  (void) ResetMagickMemory(quantum,0,sizeof(quantum));
+  (void) memset(quantum,0,sizeof(quantum));
   p=(float *) quantum;
   *p=(float) ((double) pixel*quantum_info->state.inverse_scale+
     quantum_info->minimum);
diff --git a/MagickCore/quantum.c b/MagickCore/quantum.c
index c7cd604c887..3cb96c89d11 100644
--- a/MagickCore/quantum.c
+++ b/MagickCore/quantum.c
@@ -167,7 +167,7 @@ static MagickBooleanType AcquireQuantumPixels(QuantumInfo *quantum_info,
   if (quantum_info->pixels == (MemoryInfo **) NULL)
     return(MagickFalse);
   quantum_info->extent=extent;
-  (void) ResetMagickMemory(quantum_info->pixels,0,quantum_info->number_threads*
+  (void) memset(quantum_info->pixels,0,quantum_info->number_threads*
     sizeof(*quantum_info->pixels));
   for (i=0; i < (ssize_t) quantum_info->number_threads; i++)
   {
@@ -181,7 +181,7 @@ static MagickBooleanType AcquireQuantumPixels(QuantumInfo *quantum_info,
         return(MagickFalse);
       }
     pixels=(unsigned char *)  GetVirtualMemoryBlob(quantum_info->pixels[i]);
-    (void) ResetMagickMemory(pixels,0,(extent+1)*sizeof(*pixels));
+    (void) memset(pixels,0,(extent+1)*sizeof(*pixels));
     pixels[extent]=QuantumSignature;
   }
   return(MagickTrue);
@@ -422,7 +422,7 @@ MagickExport void GetQuantumInfo(const ImageInfo *image_info,
     *option;
 
   assert(quantum_info != (QuantumInfo *) NULL);
-  (void) ResetMagickMemory(quantum_info,0,sizeof(*quantum_info));
+  (void) memset(quantum_info,0,sizeof(*quantum_info));
   quantum_info->quantum=8;
   quantum_info->maximum=1.0;
   quantum_info->scale=QuantumRange;
diff --git a/MagickCore/random.c b/MagickCore/random.c
index 28e74a897e2..68fb6ea6c16 100644
--- a/MagickCore/random.c
+++ b/MagickCore/random.c
@@ -175,7 +175,7 @@ MagickExport RandomInfo *AcquireRandomInfo(void)
     *nonce;
 
   random_info=(RandomInfo *) AcquireCriticalMemory(sizeof(*random_info));
-  (void) ResetMagickMemory(random_info,0,sizeof(*random_info));
+  (void) memset(random_info,0,sizeof(*random_info));
   random_info->signature_info=AcquireSignatureInfo();
   random_info->nonce=AcquireStringInfo(2*GetSignatureDigestsize(
     random_info->signature_info));
@@ -284,7 +284,7 @@ MagickExport RandomInfo *DestroyRandomInfo(RandomInfo *random_info)
   if (random_info->signature_info != (SignatureInfo *) NULL)
     random_info->signature_info=DestroySignatureInfo(
       random_info->signature_info);
-  (void) ResetMagickMemory(random_info->seed,0,sizeof(*random_info->seed));
+  (void) memset(random_info->seed,0,sizeof(*random_info->seed));
   random_info->signature=(~MagickCoreSignature);
   UnlockSemaphoreInfo(random_info->semaphore);
   RelinquishSemaphoreInfo(&random_info->semaphore);
diff --git a/MagickCore/registry.c b/MagickCore/registry.c
index 4aa9ef22270..7f674693271 100644
--- a/MagickCore/registry.c
+++ b/MagickCore/registry.c
@@ -512,7 +512,7 @@ MagickExport MagickBooleanType SetImageRegistry(const RegistryType type,
   if (clone_value == (void *) NULL)
     return(MagickFalse);
   registry_info=(RegistryInfo *) AcquireCriticalMemory(sizeof(*registry_info));
-  (void) ResetMagickMemory(registry_info,0,sizeof(*registry_info));
+  (void) memset(registry_info,0,sizeof(*registry_info));
   registry_info->type=type;
   registry_info->value=clone_value;
   registry_info->signature=MagickCoreSignature;
diff --git a/MagickCore/resample.c b/MagickCore/resample.c
index 4d14f28b357..3cb1a0dfbb4 100644
--- a/MagickCore/resample.c
+++ b/MagickCore/resample.c
@@ -219,7 +219,7 @@ MagickExport ResampleFilter *AcquireResampleFilter(const Image *image,
   assert(exception->signature == MagickCoreSignature);
   resample_filter=(ResampleFilter *) AcquireCriticalMemory(sizeof(
     *resample_filter));
-  (void) ResetMagickMemory(resample_filter,0,sizeof(*resample_filter));
+  (void) memset(resample_filter,0,sizeof(*resample_filter));
   resample_filter->exception=exception;
   resample_filter->image=ReferenceImage((Image *) image);
   resample_filter->view=AcquireVirtualCacheView(resample_filter->image,
diff --git a/MagickCore/resize.c b/MagickCore/resize.c
index b225aebb44c..efaaa48b10a 100644
--- a/MagickCore/resize.c
+++ b/MagickCore/resize.c
@@ -934,7 +934,7 @@ MagickPrivate ResizeFilter *AcquireResizeFilter(const Image *image,
   assert(exception->signature == MagickCoreSignature);
   (void) exception;
   resize_filter=(ResizeFilter *) AcquireCriticalMemory(sizeof(*resize_filter));
-  (void) ResetMagickMemory(resize_filter,0,sizeof(*resize_filter));
+  (void) memset(resize_filter,0,sizeof(*resize_filter));
   /*
     Defaults for the requested filter.
   */
@@ -2418,7 +2418,7 @@ static ContributionInfo **AcquireContributionThreadSet(const size_t count)
     sizeof(*contribution));
   if (contribution == (ContributionInfo **) NULL)
     return((ContributionInfo **) NULL);
-  (void) ResetMagickMemory(contribution,0,number_threads*sizeof(*contribution));
+  (void) memset(contribution,0,number_threads*sizeof(*contribution));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     contribution[i]=(ContributionInfo *) MagickAssumeAligned(
@@ -3306,7 +3306,7 @@ MagickExport Image *ScaleImage(const Image *image,const size_t columns,
   next_row=MagickTrue;
   span.y=1.0;
   scale.y=(double) scale_image->rows/(double) image->rows;
-  (void) ResetMagickMemory(y_vector,0,(size_t) MaxPixelChannels*image->columns*
+  (void) memset(y_vector,0,(size_t) MaxPixelChannels*image->columns*
     sizeof(*y_vector));
   n=0;
   status=MagickTrue;
diff --git a/MagickCore/segment.c b/MagickCore/segment.c
index 935bfa42192..3f07d9b944e 100644
--- a/MagickCore/segment.c
+++ b/MagickCore/segment.c
@@ -293,9 +293,9 @@ static MagickBooleanType Classify(Image *image,short **extrema,
   */
   cluster=(Cluster *) NULL;
   head=(Cluster *) NULL;
-  (void) ResetMagickMemory(&red,0,sizeof(red));
-  (void) ResetMagickMemory(&green,0,sizeof(green));
-  (void) ResetMagickMemory(&blue,0,sizeof(blue));
+  (void) memset(&red,0,sizeof(red));
+  (void) memset(&green,0,sizeof(green));
+  (void) memset(&blue,0,sizeof(blue));
   while (DefineRegion(extrema[Red],&red) != 0)
   {
     green.index=0;
@@ -1005,9 +1005,9 @@ MagickExport MagickBooleanType GetImageDynamicThreshold(const Image *image,
   */
   cluster=(Cluster *) NULL;
   head=(Cluster *) NULL;
-  (void) ResetMagickMemory(&red,0,sizeof(red));
-  (void) ResetMagickMemory(&green,0,sizeof(green));
-  (void) ResetMagickMemory(&blue,0,sizeof(blue));
+  (void) memset(&red,0,sizeof(red));
+  (void) memset(&green,0,sizeof(green));
+  (void) memset(&blue,0,sizeof(blue));
   while (DefineRegion(extrema[Red],&red) != 0)
   {
     green.index=0;
diff --git a/MagickCore/semaphore.c b/MagickCore/semaphore.c
index 70ba9173928..751870ff97d 100644
--- a/MagickCore/semaphore.c
+++ b/MagickCore/semaphore.c
@@ -201,7 +201,7 @@ MagickExport SemaphoreInfo *AcquireSemaphoreInfo(void)
     sizeof(*semaphore_info));
   if (semaphore_info == (SemaphoreInfo *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(semaphore_info,0,sizeof(SemaphoreInfo));
+  (void) memset(semaphore_info,0,sizeof(SemaphoreInfo));
   /*
     Initialize the semaphore.
   */
diff --git a/MagickCore/signature.c b/MagickCore/signature.c
index 30334823e55..0ce2c96464d 100644
--- a/MagickCore/signature.c
+++ b/MagickCore/signature.c
@@ -123,7 +123,7 @@ MagickPrivate SignatureInfo *AcquireSignatureInfo(void)
     lsb_first;
 
   signature_info=(SignatureInfo *) AcquireCriticalMemory(sizeof(*signature_info));
-  (void) ResetMagickMemory(signature_info,0,sizeof(*signature_info));
+  (void) memset(signature_info,0,sizeof(*signature_info));
   signature_info->digestsize=SignatureDigestsize;
   signature_info->blocksize=SignatureBlocksize;
   signature_info->digest=AcquireStringInfo(SignatureDigestsize);
@@ -236,14 +236,14 @@ MagickPrivate void FinalizeSignature(SignatureInfo *signature_info)
   datum=GetStringInfoDatum(signature_info->message);
   datum[extent++]=(unsigned char) 0x80;
   if (extent <= (unsigned int) (GetStringInfoLength(signature_info->message)-8))
-    (void) ResetMagickMemory(datum+extent,0,GetStringInfoLength(
+    (void) memset(datum+extent,0,GetStringInfoLength(
       signature_info->message)-8-extent);
   else
     {
-      (void) ResetMagickMemory(datum+extent,0,GetStringInfoLength(
+      (void) memset(datum+extent,0,GetStringInfoLength(
         signature_info->message)-extent);
       TransformSignature(signature_info);
-      (void) ResetMagickMemory(datum,0,GetStringInfoLength(
+      (void) memset(datum,0,GetStringInfoLength(
         signature_info->message)-8);
     }
   datum[56]=(unsigned char) (high_order >> 24);
@@ -749,7 +749,7 @@ RestoreMSCWarning
   T=0;
   T1=0;
   T2=0;
-  (void) ResetMagickMemory(W,0,sizeof(W));
+  (void) memset(W,0,sizeof(W));
 }
 
 /*
diff --git a/MagickCore/splay-tree.c b/MagickCore/splay-tree.c
index b2fe74f816b..f083547abd8 100644
--- a/MagickCore/splay-tree.c
+++ b/MagickCore/splay-tree.c
@@ -1146,7 +1146,7 @@ MagickExport SplayTreeInfo *NewSplayTree(
     *splay_tree;
 
   splay_tree=(SplayTreeInfo *) AcquireCriticalMemory(sizeof(*splay_tree));
-  (void) ResetMagickMemory(splay_tree,0,sizeof(*splay_tree));
+  (void) memset(splay_tree,0,sizeof(*splay_tree));
   splay_tree->root=(NodeInfo *) NULL;
   splay_tree->compare=compare;
   splay_tree->relinquish_key=relinquish_key;
diff --git a/MagickCore/statistic.c b/MagickCore/statistic.c
index bf81e58e35f..3061c68dd45 100644
--- a/MagickCore/statistic.c
+++ b/MagickCore/statistic.c
@@ -166,7 +166,7 @@ static PixelChannels **AcquirePixelThreadSet(const Image *image)
     sizeof(*pixels));
   if (pixels == (PixelChannels **) NULL)
     return((PixelChannels **) NULL);
-  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));
+  (void) memset(pixels,0,number_threads*sizeof(*pixels));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     register ssize_t
@@ -1394,20 +1394,20 @@ MagickExport ChannelMoments *GetImageMoments(const Image *image,
     sizeof(*channel_moments));
   if (channel_moments == (ChannelMoments *) NULL)
     return(channel_moments);
-  (void) ResetMagickMemory(channel_moments,0,(MaxPixelChannels+1)*
+  (void) memset(channel_moments,0,(MaxPixelChannels+1)*
     sizeof(*channel_moments));
-  (void) ResetMagickMemory(centroid,0,sizeof(centroid));
-  (void) ResetMagickMemory(M00,0,sizeof(M00));
-  (void) ResetMagickMemory(M01,0,sizeof(M01));
-  (void) ResetMagickMemory(M02,0,sizeof(M02));
-  (void) ResetMagickMemory(M03,0,sizeof(M03));
-  (void) ResetMagickMemory(M10,0,sizeof(M10));
-  (void) ResetMagickMemory(M11,0,sizeof(M11));
-  (void) ResetMagickMemory(M12,0,sizeof(M12));
-  (void) ResetMagickMemory(M20,0,sizeof(M20));
-  (void) ResetMagickMemory(M21,0,sizeof(M21));
-  (void) ResetMagickMemory(M22,0,sizeof(M22));
-  (void) ResetMagickMemory(M30,0,sizeof(M30));
+  (void) memset(centroid,0,sizeof(centroid));
+  (void) memset(M00,0,sizeof(M00));
+  (void) memset(M01,0,sizeof(M01));
+  (void) memset(M02,0,sizeof(M02));
+  (void) memset(M03,0,sizeof(M03));
+  (void) memset(M10,0,sizeof(M10));
+  (void) memset(M11,0,sizeof(M11));
+  (void) memset(M12,0,sizeof(M12));
+  (void) memset(M20,0,sizeof(M20));
+  (void) memset(M21,0,sizeof(M21));
+  (void) memset(M22,0,sizeof(M22));
+  (void) memset(M30,0,sizeof(M30));
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
   {
@@ -1986,7 +1986,7 @@ MagickExport ChannelStatistics *GetImageStatistics(const Image *image,
           channel_statistics);
       return(channel_statistics);
     }
-  (void) ResetMagickMemory(channel_statistics,0,(MaxPixelChannels+1)*
+  (void) memset(channel_statistics,0,(MaxPixelChannels+1)*
     sizeof(*channel_statistics));
   for (i=0; i <= (ssize_t) MaxPixelChannels; i++)
   {
@@ -1994,7 +1994,7 @@ MagickExport ChannelStatistics *GetImageStatistics(const Image *image,
     channel_statistics[i].maxima=(-MagickMaximumValue);
     channel_statistics[i].minima=MagickMaximumValue;
   }
-  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
+  (void) memset(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*histogram));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
@@ -2481,13 +2481,13 @@ static PixelList *AcquirePixelList(const size_t width,const size_t height)
   pixel_list=(PixelList *) AcquireMagickMemory(sizeof(*pixel_list));
   if (pixel_list == (PixelList *) NULL)
     return(pixel_list);
-  (void) ResetMagickMemory((void *) pixel_list,0,sizeof(*pixel_list));
+  (void) memset((void *) pixel_list,0,sizeof(*pixel_list));
   pixel_list->length=width*height;
   pixel_list->skip_list.nodes=(SkipNode *) AcquireAlignedMemory(65537UL,
     sizeof(*pixel_list->skip_list.nodes));
   if (pixel_list->skip_list.nodes == (SkipNode *) NULL)
     return(DestroyPixelList(pixel_list));
-  (void) ResetMagickMemory(pixel_list->skip_list.nodes,0,65537UL*
+  (void) memset(pixel_list->skip_list.nodes,0,65537UL*
     sizeof(*pixel_list->skip_list.nodes));
   pixel_list->signature=MagickCoreSignature;
   return(pixel_list);
@@ -2510,7 +2510,7 @@ static PixelList **AcquirePixelListThreadSet(const size_t width,
     sizeof(*pixel_list));
   if (pixel_list == (PixelList **) NULL)
     return((PixelList **) NULL);
-  (void) ResetMagickMemory(pixel_list,0,number_threads*sizeof(*pixel_list));
+  (void) memset(pixel_list,0,number_threads*sizeof(*pixel_list));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     pixel_list[i]=AcquirePixelList(width,height);
diff --git a/MagickCore/stream.c b/MagickCore/stream.c
index c0f5553f6a8..28070860229 100644
--- a/MagickCore/stream.c
+++ b/MagickCore/stream.c
@@ -163,7 +163,7 @@ MagickExport StreamInfo *AcquireStreamInfo(const ImageInfo *image_info,
     *stream_info;
 
   stream_info=(StreamInfo *) AcquireCriticalMemory(sizeof(*stream_info));
-  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));
+  (void) memset(stream_info,0,sizeof(*stream_info));
   stream_info->pixels=(unsigned char *) MagickAssumeAligned(
     AcquireAlignedMemory(1,sizeof(*stream_info->pixels)));
   if (stream_info->pixels == (unsigned char *) NULL)
@@ -1251,7 +1251,7 @@ static size_t WriteStreamImage(const Image *image,const void *pixels,
       stream_info->pixels=(unsigned char *) AcquireAlignedMemory(1,length);
       if (stream_info->pixels == (unsigned char *) NULL)
         return(0);
-      (void) ResetMagickMemory(stream_info->pixels,0,length);
+      (void) memset(stream_info->pixels,0,length);
       stream_info->image=image;
       write_info=CloneImageInfo(stream_info->image_info);
       (void) SetImageInfo(write_info,1,stream_info->exception);
diff --git a/MagickCore/string.c b/MagickCore/string.c
index 2bbaf110c13..091242a2547 100644
--- a/MagickCore/string.c
+++ b/MagickCore/string.c
@@ -174,7 +174,7 @@ static StringInfo *AcquireStringInfoContainer()
     *string_info;
 
   string_info=(StringInfo *) AcquireCriticalMemory(sizeof(*string_info));
-  (void) ResetMagickMemory(string_info,0,sizeof(*string_info));
+  (void) memset(string_info,0,sizeof(*string_info));
   string_info->signature=MagickCoreSignature;
   return(string_info);
 }
@@ -1192,8 +1192,8 @@ MagickExport ssize_t FormatMagickTime(const time_t time,const size_t length,
     timezone;
 
   assert(timestamp != (char *) NULL);
-  (void) ResetMagickMemory(&local_time,0,sizeof(local_time));
-  (void) ResetMagickMemory(&gm_time,0,sizeof(gm_time));
+  (void) memset(&local_time,0,sizeof(local_time));
+  (void) memset(&gm_time,0,sizeof(gm_time));
 #if defined(MAGICKCORE_HAVE_LOCALTIME_R)
   (void) localtime_r(&time,&local_time);
 #else
@@ -1666,7 +1666,7 @@ MagickExport void ResetStringInfo(StringInfo *string_info)
 {
   assert(string_info != (StringInfo *) NULL);
   assert(string_info->signature == MagickCoreSignature);
-  (void) ResetMagickMemory(string_info->datum,0,string_info->length);
+  (void) memset(string_info->datum,0,string_info->length);
 }
 
 /*
@@ -1751,7 +1751,7 @@ MagickExport void SetStringInfo(StringInfo *string_info,
   assert(source->signature == MagickCoreSignature);
   if (string_info->length == 0)
     return;
-  (void) ResetMagickMemory(string_info->datum,0,string_info->length);
+  (void) memset(string_info->datum,0,string_info->length);
   (void) memcpy(string_info->datum,source->datum,MagickMin(string_info->length,
     source->length));
 }
diff --git a/MagickCore/threshold.c b/MagickCore/threshold.c
index 4f673dc0d14..1fdd170f3df 100644
--- a/MagickCore/threshold.c
+++ b/MagickCore/threshold.c
@@ -694,7 +694,7 @@ MagickExport MagickBooleanType AutoThresholdImage(Image *image,
     ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
       image->filename);
   status=MagickTrue;
-  (void) ResetMagickMemory(histogram,0,(MaxIntensity+1UL)*sizeof(*histogram));
+  (void) memset(histogram,0,(MaxIntensity+1UL)*sizeof(*histogram));
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
   {
diff --git a/MagickCore/timer.c b/MagickCore/timer.c
index 662cde84bd9..b6f35d51aa7 100644
--- a/MagickCore/timer.c
+++ b/MagickCore/timer.c
@@ -90,7 +90,7 @@ MagickExport TimerInfo *AcquireTimerInfo(void)
     *timer_info;
 
   timer_info=(TimerInfo *) AcquireCriticalMemory(sizeof(*timer_info));
-  (void) ResetMagickMemory(timer_info,0,sizeof(*timer_info));
+  (void) memset(timer_info,0,sizeof(*timer_info));
   timer_info->signature=MagickCoreSignature;
   GetTimerInfo(timer_info);
   return(timer_info);
@@ -283,7 +283,7 @@ MagickExport void GetTimerInfo(TimerInfo *time_info)
     Create a stopwatch and start it.
   */
   assert(time_info != (TimerInfo *) NULL);
-  (void) ResetMagickMemory(time_info,0,sizeof(*time_info));
+  (void) memset(time_info,0,sizeof(*time_info));
   time_info->state=UndefinedTimerState;
   time_info->signature=MagickCoreSignature;
   StartTimer(time_info,MagickTrue);
diff --git a/MagickCore/type.c b/MagickCore/type.c
index ff02a7e181d..2cedba81694 100644
--- a/MagickCore/type.c
+++ b/MagickCore/type.c
@@ -798,7 +798,7 @@ MagickExport MagickBooleanType LoadFontConfigFonts(SplayTreeInfo *type_cache,
     type_info=(TypeInfo *) AcquireMagickMemory(sizeof(*type_info));
     if (type_info == (TypeInfo *) NULL)
       continue;
-    (void) ResetMagickMemory(type_info,0,sizeof(*type_info));
+    (void) memset(type_info,0,sizeof(*type_info));
     type_info->path=ConstantString("System Fonts");
     type_info->signature=MagickCoreSignature;
     (void) CopyMagickString(name,"Unknown",MagickPathExtent);
@@ -1179,7 +1179,7 @@ static MagickBooleanType LoadTypeCache(SplayTreeInfo *cache,const char *xml,
           Type element.
         */
         type_info=(TypeInfo *) AcquireCriticalMemory(sizeof(*type_info));
-        (void) ResetMagickMemory(type_info,0,sizeof(*type_info));
+        (void) memset(type_info,0,sizeof(*type_info));
         type_info->path=ConstantString(filename);
         type_info->signature=MagickCoreSignature;
         continue;
diff --git a/MagickCore/utility.c b/MagickCore/utility.c
index dee2e8f051e..a4634dae9d5 100644
--- a/MagickCore/utility.c
+++ b/MagickCore/utility.c
@@ -1173,7 +1173,7 @@ MagickExport MagickBooleanType GetPathAttributes(const char *path,
       errno=EINVAL;
       return(MagickFalse);
     }
-  (void) ResetMagickMemory(attributes,0,sizeof(struct stat));
+  (void) memset(attributes,0,sizeof(struct stat));
   status=stat_utf8(path,(struct stat *) attributes) == 0 ? MagickTrue :
     MagickFalse;
   return(status);
diff --git a/MagickCore/vision.c b/MagickCore/vision.c
index 8b0c2f9ec07..94bcf16bb6a 100644
--- a/MagickCore/vision.c
+++ b/MagickCore/vision.c
@@ -219,7 +219,7 @@ MagickExport Image *ConnectedComponentsImage(const Image *image,
       component_image=DestroyImage(component_image);
       ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(object,0,MaxColormapSize*sizeof(*object));
+  (void) memset(object,0,MaxColormapSize*sizeof(*object));
   for (i=0; i < (ssize_t) MaxColormapSize; i++)
   {
     object[i].id=i;
diff --git a/MagickCore/vms.c b/MagickCore/vms.c
index 96a84a7c8ed..76fef336756 100644
--- a/MagickCore/vms.c
+++ b/MagickCore/vms.c
@@ -261,7 +261,7 @@ MagickExport MagickBooleanType VMSIsMagickConflict(const char *magick)
   item_list[0].ile3$w_code=DVI$_DEVCLASS;
   item_list[0].ile3$ps_bufaddr=&device_class;
   item_list[0].ile3$ps_retlen_addr=NULL;
-  (void) ResetMagickMemory(&item_list[1],0,sizeof(item_list[1]));
+  (void) memset(&item_list[1],0,sizeof(item_list[1]));
   status=sys$getdviw(0,0,&device,&item_list,0,0,0,0);
   if ((status == SS$_NONLOCAL) ||
       ((status & 0x01) && (device_class & (DC$_DISK | DC$_TAPE))))
diff --git a/MagickCore/xml-tree.c b/MagickCore/xml-tree.c
index 008ff5f3ad6..9bc03a084af 100644
--- a/MagickCore/xml-tree.c
+++ b/MagickCore/xml-tree.c
@@ -175,7 +175,7 @@ MagickExport XMLTreeInfo *AddChildToXMLTree(XMLTreeInfo *xml_info,
   child=(XMLTreeInfo *) AcquireMagickMemory(sizeof(*child));
   if (child == (XMLTreeInfo *) NULL)
     return((XMLTreeInfo *) NULL);
-  (void) ResetMagickMemory(child,0,sizeof(*child));
+  (void) memset(child,0,sizeof(*child));
   child->tag=ConstantString(tag);
   child->attributes=sentinel;
   child->content=ConstantString("");
@@ -1494,7 +1494,7 @@ static char *ParseEntities(char *xml,char **entities,int state)
                           sizeof(*extent_xml));
                         if (extent_xml != (char *) NULL)
                           {
-                            ResetMagickMemory(extent_xml,0,extent*
+                            memset(extent_xml,0,extent*
                               sizeof(*extent_xml));
                             (void) CopyMagickString(extent_xml,p,extent*
                               sizeof(*extent_xml));
@@ -2368,7 +2368,7 @@ MagickExport XMLTreeInfo *NewXMLTreeTag(const char *tag)
   root=(XMLTreeRoot *) AcquireMagickMemory(sizeof(*root));
   if (root == (XMLTreeRoot *) NULL)
     return((XMLTreeInfo *) NULL);
-  (void) ResetMagickMemory(root,0,sizeof(*root));
+  (void) memset(root,0,sizeof(*root));
   root->root.tag=(char *) NULL;
   if (tag != (char *) NULL)
     root->root.tag=ConstantString(tag);
diff --git a/MagickCore/xwindow.c b/MagickCore/xwindow.c
index 30d8d1910ce..5ca73a4445f 100644
--- a/MagickCore/xwindow.c
+++ b/MagickCore/xwindow.c
@@ -1834,7 +1834,7 @@ MagickExport void XDestroyResourceInfo(XResourceInfo *resource_info)
       RelinquishMagickMemory(resource_info->client_name);
   if (resource_info->name != (char *) NULL)
     resource_info->name=DestroyString(resource_info->name);
-  (void) ResetMagickMemory(resource_info,0,sizeof(*resource_info));
+  (void) memset(resource_info,0,sizeof(*resource_info));
 }
 
 /*
@@ -3466,7 +3466,7 @@ MagickExport void XGetResourceInfo(const ImageInfo *image_info,
   */
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(resource_info != (XResourceInfo *) NULL);
-  (void) ResetMagickMemory(resource_info,0,sizeof(*resource_info));
+  (void) memset(resource_info,0,sizeof(*resource_info));
   resource_info->resource_database=database;
   resource_info->image_info=(ImageInfo *) image_info;
   (void) SetImageInfoProgressMonitor(resource_info->image_info,
@@ -5140,7 +5140,7 @@ MagickPrivate XWindows *XInitializeWindows(Display *display,
         "...");
       return((XWindows *) NULL);
     }
-  (void) ResetMagickMemory(windows,0,sizeof(*windows));
+  (void) memset(windows,0,sizeof(*windows));
   windows->pixel_info=(XPixelInfo *) AcquireMagickMemory(
     sizeof(*windows->pixel_info));
   windows->icon_pixel=(XPixelInfo *) AcquireMagickMemory(
@@ -5648,7 +5648,7 @@ MagickPrivate MagickBooleanType XMakeImage(Display *display,
           ximage->data=(char *) AcquireQuantumMemory((size_t)
             ximage->bytes_per_line,(size_t) ximage->depth*ximage->height);
           if (ximage->data != (char *) NULL)
-            (void) ResetMagickMemory(ximage->data,0,(size_t)
+            (void) memset(ximage->data,0,(size_t)
               ximage->bytes_per_line*ximage->depth*ximage->height);
         }
       else
@@ -5656,7 +5656,7 @@ MagickPrivate MagickBooleanType XMakeImage(Display *display,
           ximage->data=(char *) AcquireQuantumMemory((size_t)
             ximage->bytes_per_line,(size_t) ximage->height);
           if (ximage->data != (char *) NULL)
-            (void) ResetMagickMemory(ximage->data,0,(size_t)
+            (void) memset(ximage->data,0,(size_t)
               ximage->bytes_per_line*ximage->height);
         }
     }
diff --git a/MagickWand/animate.c b/MagickWand/animate.c
index 6758f04dbf1..5cfdd2ef8a9 100644
--- a/MagickWand/animate.c
+++ b/MagickWand/animate.c
@@ -327,7 +327,7 @@ WandExport MagickBooleanType AnimateImageCommand(ImageInfo *image_info,
   pend=MagickFalse;
   respect_parenthesis=MagickFalse;
   resource_database=(XrmDatabase) NULL;
-  (void) ResetMagickMemory(&resource_info,0,sizeof(XResourceInfo));
+  (void) memset(&resource_info,0,sizeof(XResourceInfo));
   server_name=(char *) NULL;
   status=MagickTrue;
   /*
diff --git a/MagickWand/composite.c b/MagickWand/composite.c
index 77066ca4c91..0671b67911f 100644
--- a/MagickWand/composite.c
+++ b/MagickWand/composite.c
@@ -372,7 +372,7 @@ static MagickBooleanType CompositeUsage(void)
 
 static void GetCompositeOptions(CompositeOptions *composite_options)
 {
-  (void) ResetMagickMemory(composite_options,0,sizeof(*composite_options));
+  (void) memset(composite_options,0,sizeof(*composite_options));
   composite_options->channel=DefaultChannels;
   composite_options->compose=OverCompositeOp;
 }
diff --git a/MagickWand/display.c b/MagickWand/display.c
index 784446397eb..bb2d8ef4d14 100644
--- a/MagickWand/display.c
+++ b/MagickWand/display.c
@@ -379,7 +379,7 @@ WandExport MagickBooleanType DisplayImageCommand(ImageInfo *image_info,
   respect_parenthesis=MagickFalse;
   nostdin=MagickFalse;
   resource_database=(XrmDatabase) NULL;
-  (void) ResetMagickMemory(&resource_info,0,sizeof(resource_info));
+  (void) memset(&resource_info,0,sizeof(resource_info));
   server_name=(char *) NULL;
   state=0;
   status=MagickTrue;
diff --git a/MagickWand/drawing-wand.c b/MagickWand/drawing-wand.c
index cdd785c29ac..584fee842dc 100644
--- a/MagickWand/drawing-wand.c
+++ b/MagickWand/drawing-wand.c
@@ -498,7 +498,7 @@ WandExport DrawingWand *CloneDrawingWand(const DrawingWand *wand)
   if (clone_wand == (DrawingWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,
       "MemoryAllocationFailed",GetExceptionMessage(errno));
-  (void) ResetMagickMemory(clone_wand,0,sizeof(*clone_wand));
+  (void) memset(clone_wand,0,sizeof(*clone_wand));
   clone_wand->id=AcquireWandId();
   (void) FormatLocaleString(clone_wand->name,MagickPathExtent,
     "DrawingWand-%.20g",(double) clone_wand->id);
@@ -6715,7 +6715,7 @@ WandExport DrawingWand *NewDrawingWand(void)
   if (wand == (DrawingWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       GetExceptionMessage(errno));
-  (void) ResetMagickMemory(wand,0,sizeof(*wand));
+  (void) memset(wand,0,sizeof(*wand));
   wand->id=AcquireWandId();
   (void) FormatLocaleString(wand->name,MagickPathExtent,"%s-%.20g",
     DrawingWandId,(double) wand->id);
diff --git a/MagickWand/import.c b/MagickWand/import.c
index be13c14a119..c4a5078128e 100644
--- a/MagickWand/import.c
+++ b/MagickWand/import.c
@@ -315,7 +315,7 @@ WandExport MagickBooleanType ImportImageCommand(ImageInfo *image_info,
   pend=MagickFalse;
   resource_database=(XrmDatabase) NULL;
   respect_parenthesis=MagickFalse;
-  (void) ResetMagickMemory(&resource_info,0,sizeof(resource_info));
+  (void) memset(&resource_info,0,sizeof(resource_info));
   server_name=(char *) NULL;
   status=MagickTrue;
   SetNotifyHandlers;
diff --git a/MagickWand/magick-image.c b/MagickWand/magick-image.c
index e7a86d027ab..5286015494b 100644
--- a/MagickWand/magick-image.c
+++ b/MagickWand/magick-image.c
@@ -98,7 +98,7 @@ static MagickWand *CloneMagickWandFromImages(const MagickWand *wand,
   if (clone_wand == (MagickWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       images->filename);
-  (void) ResetMagickMemory(clone_wand,0,sizeof(*clone_wand));
+  (void) memset(clone_wand,0,sizeof(*clone_wand));
   clone_wand->id=AcquireWandId();
   (void) FormatLocaleString(clone_wand->name,MagickPathExtent,"%s-%.20g",
     MagickWandId,(double) clone_wand->id);
@@ -3424,7 +3424,7 @@ WandExport MagickBooleanType MagickFrameImage(MagickWand *wand,
     (void) LogMagickEvent(WandEvent,GetMagickModule(),"%s",wand->name);
   if (wand->images == (Image *) NULL)
     ThrowWandException(WandError,"ContainsNoImages",wand->name);
-  (void) ResetMagickMemory(&frame_info,0,sizeof(frame_info));
+  (void) memset(&frame_info,0,sizeof(frame_info));
   frame_info.width=wand->images->columns+2*width;
   frame_info.height=wand->images->rows+2*height;
   frame_info.x=(ssize_t) width;
diff --git a/MagickWand/magick-property.c b/MagickWand/magick-property.c
index 5e6d9fbe7f1..fa3f795646a 100644
--- a/MagickWand/magick-property.c
+++ b/MagickWand/magick-property.c
@@ -1261,7 +1261,7 @@ WandExport MagickBooleanType MagickGetPage(const MagickWand *wand,
   if (wand->debug != MagickFalse)
     (void) LogMagickEvent(WandEvent,GetMagickModule(),"%s",wand->name);
 
-  (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+  (void) memset(&geometry,0,sizeof(geometry));
   (void) ParseAbsoluteGeometry(wand->image_info->page,&geometry);
   *width=geometry.width;
   *height=geometry.height;
@@ -1601,7 +1601,7 @@ WandExport MagickBooleanType MagickGetSize(const MagickWand *wand,
   if (wand->debug != MagickFalse)
     (void) LogMagickEvent(WandEvent,GetMagickModule(),"%s",wand->name);
 
-  (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+  (void) memset(&geometry,0,sizeof(geometry));
   (void) ParseAbsoluteGeometry(wand->image_info->size,&geometry);
   *columns=geometry.width;
   *rows=geometry.height;
@@ -1645,7 +1645,7 @@ WandExport MagickBooleanType MagickGetSizeOffset(const MagickWand *wand,
   if (wand->debug != MagickFalse)
     (void) LogMagickEvent(WandEvent,GetMagickModule(),"%s",wand->name);
 
-  (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+  (void) memset(&geometry,0,sizeof(geometry));
   (void) ParseAbsoluteGeometry(wand->image_info->size,&geometry);
   *offset=geometry.x;
   return(MagickTrue);
diff --git a/MagickWand/magick-wand.c b/MagickWand/magick-wand.c
index 5354a73b510..4d383c31f06 100644
--- a/MagickWand/magick-wand.c
+++ b/MagickWand/magick-wand.c
@@ -124,7 +124,7 @@ WandExport MagickWand *CloneMagickWand(const MagickWand *wand)
   if (clone_wand == (MagickWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       wand->name);
-  (void) ResetMagickMemory(clone_wand,0,sizeof(*clone_wand));
+  (void) memset(clone_wand,0,sizeof(*clone_wand));
   clone_wand->id=AcquireWandId();
   (void) FormatLocaleString(clone_wand->name,MagickPathExtent,"%s-%.20g",
     MagickWandId,(double) clone_wand->id);
@@ -545,7 +545,7 @@ WandExport double *MagickQueryFontMetrics(MagickWand *wand,
       return((double *) NULL);
     }
   (void) CloneString(&draw_info->text,text);
-  (void) ResetMagickMemory(&metrics,0,sizeof(metrics));
+  (void) memset(&metrics,0,sizeof(metrics));
   status=GetTypeMetrics(wand->images,draw_info,&metrics,wand->exception);
   draw_info=DestroyDrawInfo(draw_info);
   if (status == MagickFalse)
@@ -652,7 +652,7 @@ WandExport double *MagickQueryMultilineFontMetrics(MagickWand *wand,
       return((double *) NULL);
     }
   (void) CloneString(&draw_info->text,text);
-  (void) ResetMagickMemory(&metrics,0,sizeof(metrics));
+  (void) memset(&metrics,0,sizeof(metrics));
   status=GetMultilineTypeMetrics(wand->images,draw_info,&metrics,
     wand->exception);
   draw_info=DestroyDrawInfo(draw_info);
@@ -1066,7 +1066,7 @@ WandExport MagickWand *NewMagickWand(void)
   if (wand == (MagickWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       GetExceptionMessage(errno));
-  (void) ResetMagickMemory(wand,0,sizeof(*wand));
+  (void) memset(wand,0,sizeof(*wand));
   wand->id=AcquireWandId();
   (void) FormatLocaleString(wand->name,MagickPathExtent,"%s-%.20g",MagickWandId,
     (double) wand->id);
diff --git a/MagickWand/mogrify.c b/MagickWand/mogrify.c
index 5365053b47a..72070009bf5 100644
--- a/MagickWand/mogrify.c
+++ b/MagickWand/mogrify.c
@@ -552,7 +552,7 @@ static Image *SparseColorOption(const Image *image,
       "MemoryAllocationFailed","%s","SparseColorOption");
     return( (Image *) NULL);
   }
-  (void) ResetMagickMemory(sparse_arguments,0,number_arguments*
+  (void) memset(sparse_arguments,0,number_arguments*
     sizeof(*sparse_arguments));
   p=arguments;
   x=0;
@@ -1443,7 +1443,7 @@ WandExport MagickBooleanType MogrifyImage(ImageInfo *image_info,const int argc,
             if (arguments == (double *) NULL)
               ThrowWandFatalException(ResourceLimitFatalError,
                 "MemoryAllocationFailed",(*image)->filename);
-            (void) ResetMagickMemory(arguments,0,number_arguments*
+            (void) memset(arguments,0,number_arguments*
               sizeof(*arguments));
             p=(char *) args;
             for (x=0; (x < (ssize_t) number_arguments) && (*p != '\0'); x++)
@@ -1748,7 +1748,7 @@ WandExport MagickBooleanType MogrifyImage(ImageInfo *image_info,const int argc,
             if (parameters == (double *) NULL)
               ThrowWandFatalException(ResourceLimitFatalError,
                 "MemoryAllocationFailed",(*image)->filename);
-            (void) ResetMagickMemory(parameters,0,number_parameters*
+            (void) memset(parameters,0,number_parameters*
               sizeof(*parameters));
             p=(char *) arguments;
             for (x=0; (x < (ssize_t) number_parameters) && (*p != '\0'); x++)
@@ -7328,7 +7328,7 @@ WandExport MagickBooleanType MogrifyImageInfo(ImageInfo *image_info,
                 (void) CloneString(&image_info->page,(char *) NULL);
                 break;
               }
-            (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+            (void) memset(&geometry,0,sizeof(geometry));
             image_option=GetImageOption(image_info,"page");
             if (image_option != (const char *) NULL)
               flags=ParseAbsoluteGeometry(image_option,&geometry);
@@ -8618,7 +8618,7 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,
             if (arguments == (double *) NULL)
               ThrowWandFatalException(ResourceLimitFatalError,
                 "MemoryAllocationFailed",(*images)->filename);
-            (void) ResetMagickMemory(arguments,0,number_arguments*
+            (void) memset(arguments,0,number_arguments*
               sizeof(*arguments));
             p=(char *) args;
             for (x=0; (x < (ssize_t) number_arguments) && (*p != '\0'); x++)
diff --git a/MagickWand/operation.c b/MagickWand/operation.c
index a3f94999966..aaf2a79edcd 100644
--- a/MagickWand/operation.c
+++ b/MagickWand/operation.c
@@ -259,7 +259,7 @@ static Image *SparseColorOption(const Image *image,
       "MemoryAllocationFailed","%s","SparseColorOption");
     return( (Image *) NULL);
   }
-  (void) ResetMagickMemory(sparse_arguments,0,number_arguments*
+  (void) memset(sparse_arguments,0,number_arguments*
     sizeof(*sparse_arguments));
   p=arguments;
   x=0;
@@ -1187,7 +1187,7 @@ WandPrivate void CLISettingOptionInfo(MagickCLI *cli_wand,
               (void) CloneString(&_image_info->page,(char *) NULL);
               break;
             }
-          (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+          (void) memset(&geometry,0,sizeof(geometry));
           image_option=GetImageOption(_image_info,"page");
           if (image_option != (const char *) NULL)
             flags=ParseAbsoluteGeometry(image_option,&geometry);
diff --git a/MagickWand/pixel-iterator.c b/MagickWand/pixel-iterator.c
index b1cc54d5c53..17512152a6b 100644
--- a/MagickWand/pixel-iterator.c
+++ b/MagickWand/pixel-iterator.c
@@ -166,7 +166,7 @@ WandExport PixelIterator *ClonePixelIterator(const PixelIterator *iterator)
   if (clone_iterator == (PixelIterator *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       iterator->name);
-  (void) ResetMagickMemory(clone_iterator,0,sizeof(*clone_iterator));
+  (void) memset(clone_iterator,0,sizeof(*clone_iterator));
   clone_iterator->id=AcquireWandId();
   (void) FormatLocaleString(clone_iterator->name,MagickPathExtent,"%s-%.20g",
     PixelIteratorId,(double) clone_iterator->id);
@@ -320,7 +320,7 @@ WandExport PixelIterator *NewPixelIterator(MagickWand *wand)
   if (iterator == (PixelIterator *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       GetExceptionMessage(errno));
-  (void) ResetMagickMemory(iterator,0,sizeof(*iterator));
+  (void) memset(iterator,0,sizeof(*iterator));
   iterator->id=AcquireWandId();
   (void) FormatLocaleString(iterator->name,MagickPathExtent,"%s-%.20g",
     PixelIteratorId,(double) iterator->id);
@@ -439,7 +439,7 @@ WandExport PixelIterator *NewPixelRegionIterator(MagickWand *wand,
   if (iterator == (PixelIterator *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       wand->name);
-  (void) ResetMagickMemory(iterator,0,sizeof(*iterator));
+  (void) memset(iterator,0,sizeof(*iterator));
   iterator->id=AcquireWandId();
   (void) FormatLocaleString(iterator->name,MagickPathExtent,"%s-%.20g",
     PixelIteratorId,(double) iterator->id);
diff --git a/MagickWand/pixel-wand.c b/MagickWand/pixel-wand.c
index 8f58a7373a1..d512a7611d2 100644
--- a/MagickWand/pixel-wand.c
+++ b/MagickWand/pixel-wand.c
@@ -152,7 +152,7 @@ WandExport PixelWand *ClonePixelWand(const PixelWand *wand)
   if (clone_wand == (PixelWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       wand->name);
-  (void) ResetMagickMemory(clone_wand,0,sizeof(*clone_wand));
+  (void) memset(clone_wand,0,sizeof(*clone_wand));
   clone_wand->id=AcquireWandId();
   (void) FormatLocaleString(clone_wand->name,MagickPathExtent,"%s-%.20g",
     PixelWandId,(double) clone_wand->id);
@@ -404,7 +404,7 @@ WandExport PixelWand *NewPixelWand(void)
   if (wand == (PixelWand *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       GetExceptionMessage(errno));
-  (void) ResetMagickMemory(wand,0,sizeof(*wand));
+  (void) memset(wand,0,sizeof(*wand));
   wand->id=AcquireWandId();
   (void) FormatLocaleString(wand->name,MagickPathExtent,"%s-%.20g",PixelWandId,
     (double) wand->id);
diff --git a/MagickWand/script-token.c b/MagickWand/script-token.c
index 9d2bb8c6654..c3655c91e7b 100644
--- a/MagickWand/script-token.c
+++ b/MagickWand/script-token.c
@@ -210,7 +210,7 @@ WandExport ScriptTokenInfo *AcquireScriptTokenInfo(const char *filename)
   token_info=(ScriptTokenInfo *) AcquireMagickMemory(sizeof(*token_info));
   if (token_info == (ScriptTokenInfo *) NULL)
     return token_info;
-  (void) ResetMagickMemory(token_info,0,sizeof(*token_info));
+  (void) memset(token_info,0,sizeof(*token_info));
 
   token_info->opened=MagickFalse;
   if ( LocaleCompare(filename,"-") == 0 ) {
diff --git a/MagickWand/wand-view.c b/MagickWand/wand-view.c
index 484f63e9aa4..cdf17371b37 100644
--- a/MagickWand/wand-view.c
+++ b/MagickWand/wand-view.c
@@ -131,7 +131,7 @@ WandExport WandView *CloneWandView(const WandView *wand_view)
   if (clone_view == (WandView *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       wand_view->name);
-  (void) ResetMagickMemory(clone_view,0,sizeof(*clone_view));
+  (void) memset(clone_view,0,sizeof(*clone_view));
   clone_view->id=AcquireWandId();
   (void) FormatLocaleString(clone_view->name,MagickPathExtent,"%s-%.20g",
     WandViewId,(double) clone_view->id);
@@ -730,7 +730,7 @@ static PixelWand ***AcquirePixelsThreadSet(const size_t number_wands)
     sizeof(*pixel_wands));
   if (pixel_wands == (PixelWand ***) NULL)
     return((PixelWand ***) NULL);
-  (void) ResetMagickMemory(pixel_wands,0,number_threads*sizeof(*pixel_wands));
+  (void) memset(pixel_wands,0,number_threads*sizeof(*pixel_wands));
   for (i=0; i < (ssize_t) number_threads; i++)
   {
     pixel_wands[i]=NewPixelWands(number_wands);
@@ -754,7 +754,7 @@ WandExport WandView *NewWandView(MagickWand *wand)
   if (wand_view == (WandView *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       GetExceptionMessage(errno));
-  (void) ResetMagickMemory(wand_view,0,sizeof(*wand_view));
+  (void) memset(wand_view,0,sizeof(*wand_view));
   wand_view->id=AcquireWandId();
   (void) FormatLocaleString(wand_view->name,MagickPathExtent,"%s-%.20g",
     WandViewId,(double) wand_view->id);
@@ -816,7 +816,7 @@ WandExport WandView *NewWandViewExtent(MagickWand *wand,const ssize_t x,
   if (wand_view == (WandView *) NULL)
     ThrowWandFatalException(ResourceLimitFatalError,"MemoryAllocationFailed",
       GetExceptionMessage(errno));
-  (void) ResetMagickMemory(wand_view,0,sizeof(*wand_view));
+  (void) memset(wand_view,0,sizeof(*wand_view));
   wand_view->id=AcquireWandId();
   (void) FormatLocaleString(wand_view->name,MagickPathExtent,"%s-%.20g",
     WandViewId,(double) wand_view->id);
diff --git a/coders/bmp.c b/coders/bmp.c
index 579578e16a0..36fd03b0eac 100644
--- a/coders/bmp.c
+++ b/coders/bmp.c
@@ -222,7 +222,7 @@ static MagickBooleanType DecodeImage(Image *image,const size_t compression,
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(pixels != (unsigned char *) NULL);
-  (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(*pixels));
+  (void) memset(pixels,0,number_pixels*sizeof(*pixels));
   byte=0;
   x=0;
   p=pixels;
@@ -577,7 +577,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Determine if this a BMP file.
   */
-  (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));
+  (void) memset(&bmp_info,0,sizeof(bmp_info));
   bmp_info.ba_offset=0;
   start_position=0;
   offset_bits=0;
@@ -1047,8 +1047,8 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)
             bmp_info.blue_mask=0x0000001fU;
           }
       }
-    (void) ResetMagickMemory(&shift,0,sizeof(shift));
-    (void) ResetMagickMemory(&quantum_bits,0,sizeof(quantum_bits));
+    (void) memset(&shift,0,sizeof(shift));
+    (void) memset(&quantum_bits,0,sizeof(quantum_bits));
     if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))
       {
         register unsigned int
@@ -1675,7 +1675,7 @@ static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,
     */
     if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
       (void) TransformImageColorspace(image,sRGBColorspace,exception);
-    (void) ResetMagickMemory(&bmp_info,0,sizeof(bmp_info));
+    (void) memset(&bmp_info,0,sizeof(bmp_info));
     bmp_info.file_size=14+12;
     if (type > 2)
       bmp_info.file_size+=28;
@@ -1854,7 +1854,7 @@ static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
-    (void) ResetMagickMemory(pixels,0,(size_t) bmp_info.image_size);
+    (void) memset(pixels,0,(size_t) bmp_info.image_size);
     switch (bmp_info.bits_per_pixel)
     {
       case 1:
diff --git a/coders/cals.c b/coders/cals.c
index b1b4c7fa4cf..842cff4acc5 100644
--- a/coders/cals.c
+++ b/coders/cals.c
@@ -196,7 +196,7 @@ static Image *ReadCALSImage(const ImageInfo *image_info,
   /*
     Read CALS header.
   */
-  (void) ResetMagickMemory(header,0,sizeof(header));
+  (void) memset(header,0,sizeof(header));
   density=0;
   direction=0;
   orientation=1;
@@ -416,7 +416,7 @@ static ssize_t WriteCALSRecord(Image *image,const char *data)
   if (i < 128)
     {
       i=128-i;
-      (void) ResetMagickMemory(pad,' ',(size_t) i);
+      (void) memset(pad,' ',(size_t) i);
       count=WriteBlob(image,(size_t) i,(const unsigned char *) pad);
     }
   return(count);
@@ -545,7 +545,7 @@ static MagickBooleanType WriteCALSImage(const ImageInfo *image_info,
     (unsigned long) density);
   count=WriteCALSRecord(image,header);
   count=WriteCALSRecord(image,"notes: NONE");
-  (void) ResetMagickMemory(header,' ',128);
+  (void) memset(header,' ',128);
   for (i=0; i < 5; i++)
     (void) WriteBlob(image,128,(unsigned char *) header);
   /*
diff --git a/coders/cin.c b/coders/cin.c
index dc872a4720e..a50eb2b007f 100644
--- a/coders/cin.c
+++ b/coders/cin.c
@@ -447,7 +447,7 @@ static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if ((count != 4) ||
       ((LocaleNCompare((char *) magick,"\200\052\137\327",4) != 0)))
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
-  ResetMagickMemory(&cin,0,sizeof(cin));
+  memset(&cin,0,sizeof(cin));
   image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&
     (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;
   cin.file.image_offset=ReadBlobLong(image);
@@ -622,7 +622,7 @@ static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)
   (void) CopyMagickString(property,cin.origination.model,
     sizeof(cin.origination.model));
   (void) SetImageProperty(image,"dpx:origination.model",property,exception);
-  (void) ResetMagickMemory(cin.origination.serial,0, 
+  (void) memset(cin.origination.serial,0, 
     sizeof(cin.origination.serial));
   offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)
     cin.origination.serial);
@@ -957,7 +957,7 @@ static MagickBooleanType WriteCINImage(const ImageInfo *image_info,Image *image,
   /*
     Write image information.
   */
-  (void) ResetMagickMemory(&cin,0,sizeof(cin));
+  (void) memset(&cin,0,sizeof(cin));
   offset=0;
   cin.file.magic=0x802A5FD7UL;
   offset+=WriteBlobLong(image,(unsigned int) cin.file.magic);
diff --git a/coders/clipboard.c b/coders/clipboard.c
index 77414802430..0066e66fb25 100644
--- a/coders/clipboard.c
+++ b/coders/clipboard.c
@@ -175,7 +175,7 @@ static Image *ReadCLIPBOARDImage(const ImageInfo *image_info,
       /*
         Initialize the bitmap header info.
       */
-      (void) ResetMagickMemory(&DIBinfo,0,sizeof(BITMAPINFO));
+      (void) memset(&DIBinfo,0,sizeof(BITMAPINFO));
       DIBinfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
       DIBinfo.bmiHeader.biWidth=(LONG) image->columns;
       DIBinfo.bmiHeader.biHeight=(-1)*(LONG) image->rows;
diff --git a/coders/cut.c b/coders/cut.c
index d127e2319f5..f4af542b213 100644
--- a/coders/cut.c
+++ b/coders/cut.c
@@ -560,7 +560,7 @@ static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)
           if((int) RunCount>0x80)
             {
               RunValue=(unsigned char) ReadBlobByte(image);
-              (void) ResetMagickMemory(ptrB,(int) RunValue,(size_t) RunCountMasked);
+              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);
             }
           else {
             (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);
diff --git a/coders/dcm.c b/coders/dcm.c
index f56109b2d3d..5c8646468b3 100644
--- a/coders/dcm.c
+++ b/coders/dcm.c
@@ -2838,7 +2838,7 @@ static MagickBooleanType ReadDCMPixels(Image *image,DCMInfo *info,
   byte=0;
   i=0;
   status=MagickTrue;
-  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
+  (void) memset(&pixel,0,sizeof(pixel));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
@@ -3089,7 +3089,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
   stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));
   if (stream_info == (DCMStreamInfo *) NULL)
     ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));
+  (void) memset(stream_info,0,sizeof(*stream_info));
   count=ReadBlob(image,128,(unsigned char *) magick);
   if (count != 128)
     ThrowDCMException(CorruptImageError,"ImproperImageHeader");
@@ -3564,7 +3564,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
               sizeof(*graymap));
             if (graymap == (int *) NULL)
               ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");
-            (void) ResetMagickMemory(graymap,0,MagickMax(colors,65536)*
+            (void) memset(graymap,0,MagickMax(colors,65536)*
               sizeof(*graymap));
             for (i=0; i < (ssize_t) colors; i++)
               if (info.bytes_per_pixel == 1)
@@ -3591,7 +3591,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
               sizeof(*redmap));
             if (redmap == (int *) NULL)
               ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");
-            (void) ResetMagickMemory(redmap,0,MagickMax(colors,65536)*
+            (void) memset(redmap,0,MagickMax(colors,65536)*
               sizeof(*redmap));
             p=data;
             for (i=0; i < (ssize_t) colors; i++)
@@ -3623,7 +3623,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
               sizeof(*greenmap));
             if (greenmap == (int *) NULL)
               ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");
-            (void) ResetMagickMemory(greenmap,0,MagickMax(colors,65536)*
+            (void) memset(greenmap,0,MagickMax(colors,65536)*
               sizeof(*greenmap));
             p=data;
             for (i=0; i < (ssize_t) colors; i++)
@@ -3655,7 +3655,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
               sizeof(*bluemap));
             if (bluemap == (int *) NULL)
               ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");
-            (void) ResetMagickMemory(bluemap,0,MagickMax(colors,65536)*
+            (void) memset(bluemap,0,MagickMax(colors,65536)*
               sizeof(*bluemap));
             p=data;
             for (i=0; i < (ssize_t) colors; i++)
@@ -3901,7 +3901,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
         sizeof(*info.scale));
       if (info.scale == (Quantum *) NULL)
         ThrowDCMException(ResourceLimitError,"MemoryAllocationFailed");
-      (void) ResetMagickMemory(info.scale,0,MagickMax(length,256)*
+      (void) memset(info.scale,0,MagickMax(length,256)*
         sizeof(*info.scale));
       range=GetQuantumRange(info.depth);
       for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)
diff --git a/coders/dds.c b/coders/dds.c
index 872668d7c41..44605ef5855 100644
--- a/coders/dds.c
+++ b/coders/dds.c
@@ -2940,7 +2940,7 @@ static void WriteDDSInfo(Image *image, const size_t pixelFormat,
 
   (void) WriteBlobLSBLong(image,0x00);
   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);
-  (void) ResetMagickMemory(software,0,sizeof(software));
+  (void) memset(software,0,sizeof(software));
   (void) CopyMagickString(software,"IMAGEMAGICK",MagickPathExtent);
   (void) WriteBlob(image,44,(unsigned char *) software);
 
diff --git a/coders/dib.c b/coders/dib.c
index 05f50bca139..8d1a72c43c4 100644
--- a/coders/dib.c
+++ b/coders/dib.c
@@ -183,7 +183,7 @@ static MagickBooleanType DecodeImage(Image *image,
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(pixels != (unsigned char *) NULL);
-  (void) ResetMagickMemory(pixels,0,number_pixels*sizeof(*pixels));
+  (void) memset(pixels,0,number_pixels*sizeof(*pixels));
   byte=0;
   x=0;
   p=pixels;
@@ -511,7 +511,7 @@ static Image *ReadDIBImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Determine if this a DIB file.
   */
-  (void) ResetMagickMemory(&dib_info,0,sizeof(dib_info));
+  (void) memset(&dib_info,0,sizeof(dib_info));
   dib_info.size=ReadBlobLSBLong(image);
   if (dib_info.size != 40)
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
@@ -1175,7 +1175,7 @@ static MagickBooleanType WriteDIBImage(const ImageInfo *image_info,Image *image,
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(pixels,0,dib_info.image_size);
+  (void) memset(pixels,0,dib_info.image_size);
   switch (dib_info.bits_per_pixel)
   {
     case 1:
diff --git a/coders/djvu.c b/coders/djvu.c
index 66197793ff6..2fe226a6683 100644
--- a/coders/djvu.c
+++ b/coders/djvu.c
@@ -810,7 +810,7 @@ static Image *ReadDJVUImage(const ImageInfo *image_info,
   /*
    * Initialize members of the MngInfo structure.
    */
-  (void) ResetMagickMemory(lc,0,sizeof(LoadContext));
+  (void) memset(lc,0,sizeof(LoadContext));
 
   lc->image = image;
   lc->pages = 0;
diff --git a/coders/dpx.c b/coders/dpx.c
index 734a818ba7e..0944ff7dfb2 100644
--- a/coders/dpx.c
+++ b/coders/dpx.c
@@ -719,7 +719,7 @@ static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)
   image->endian=LSBEndian;
   if (LocaleNCompare(magick,"SDPX",4) == 0)
     image->endian=MSBEndian;
-  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));
+  (void) memset(&dpx,0,sizeof(dpx));
   dpx.file.image_offset=ReadBlobLong(image);
   offset+=4;
   offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)
@@ -1533,7 +1533,7 @@ static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,
   /*
     Write file header.
   */
-  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));
+  (void) memset(&dpx,0,sizeof(dpx));
   offset=0;
   dpx.file.magic=0x53445058U;
   offset+=WriteBlobLong(image,dpx.file.magic);
@@ -1788,36 +1788,36 @@ static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,
   /*
     Write film header.
   */
-  (void) ResetMagickMemory(dpx.film.id,0,sizeof(dpx.film.id));
+  (void) memset(dpx.film.id,0,sizeof(dpx.film.id));
   value=GetDPXProperty(image,"dpx:film.id",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.id,value,sizeof(dpx.film.id)-1);
   offset+=WriteBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);
-  (void) ResetMagickMemory(dpx.film.type,0,sizeof(dpx.film.type));
+  (void) memset(dpx.film.type,0,sizeof(dpx.film.type));
   value=GetDPXProperty(image,"dpx:film.type",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.type,value,sizeof(dpx.film.type)-1);
   offset+=WriteBlob(image,sizeof(dpx.film.type),(unsigned char *)
     dpx.film.type);
-  (void) ResetMagickMemory(dpx.film.offset,0,sizeof(dpx.film.offset));
+  (void) memset(dpx.film.offset,0,sizeof(dpx.film.offset));
   value=GetDPXProperty(image,"dpx:film.offset",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.offset,value,sizeof(dpx.film.offset)-1);
   offset+=WriteBlob(image,sizeof(dpx.film.offset),(unsigned char *)
     dpx.film.offset);
-  (void) ResetMagickMemory(dpx.film.prefix,0,sizeof(dpx.film.prefix));
+  (void) memset(dpx.film.prefix,0,sizeof(dpx.film.prefix));
   value=GetDPXProperty(image,"dpx:film.prefix",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.prefix,value,sizeof(dpx.film.prefix)-1);
   offset+=WriteBlob(image,sizeof(dpx.film.prefix),(unsigned char *)
     dpx.film.prefix);
-  (void) ResetMagickMemory(dpx.film.count,0,sizeof(dpx.film.count));
+  (void) memset(dpx.film.count,0,sizeof(dpx.film.count));
   value=GetDPXProperty(image,"dpx:film.count",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.count,value,sizeof(dpx.film.count)-1);
   offset+=WriteBlob(image,sizeof(dpx.film.count),(unsigned char *)
     dpx.film.count);
-  (void) ResetMagickMemory(dpx.film.format,0,sizeof(dpx.film.format));
+  (void) memset(dpx.film.format,0,sizeof(dpx.film.format));
   value=GetDPXProperty(image,"dpx:film.format",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.format,value,sizeof(dpx.film.format)-1);
@@ -1848,7 +1848,7 @@ static MagickBooleanType WriteDPXImage(const ImageInfo *image_info,Image *image,
   if (value != (const char *) NULL)
     dpx.film.shutter_angle=StringToDouble(value,(char **) NULL);
   offset+=WriteBlobFloat(image,dpx.film.shutter_angle);
-  (void) ResetMagickMemory(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));
+  (void) memset(dpx.film.frame_id,0,sizeof(dpx.film.frame_id));
   value=GetDPXProperty(image,"dpx:film.frame_id",exception);
   if (value != (const char *) NULL)
     (void) strncpy(dpx.film.frame_id,value,sizeof(dpx.film.frame_id)-1);
diff --git a/coders/emf.c b/coders/emf.c
index c39571e21b8..ec35f1f0488 100644
--- a/coders/emf.c
+++ b/coders/emf.c
@@ -567,7 +567,7 @@ static Image *ReadEMFImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Initialize the bitmap header info.
   */
-  (void) ResetMagickMemory(&DIBinfo,0,sizeof(BITMAPINFO));
+  (void) memset(&DIBinfo,0,sizeof(BITMAPINFO));
   DIBinfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
   DIBinfo.bmiHeader.biWidth=(LONG) image->columns;
   DIBinfo.bmiHeader.biHeight=(-1)*(LONG) image->rows;
diff --git a/coders/ept.c b/coders/ept.c
index bda4486fc1d..89f429cb1c5 100644
--- a/coders/ept.c
+++ b/coders/ept.c
@@ -209,7 +209,7 @@ static Image *ReadEPTImage(const ImageInfo *image_info,ExceptionInfo *exception)
     ept_info.postscript_length+1,sizeof(*ept_info.postscript));
   if (ept_info.postscript == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(ept_info.postscript,0,(ept_info.postscript_length+1)*
+  (void) memset(ept_info.postscript,0,(ept_info.postscript_length+1)*
     sizeof(*ept_info.postscript));
   ept_info.tiff=(unsigned char *) AcquireQuantumMemory(ept_info.tiff_length+1,
     sizeof(*ept_info.tiff));
@@ -219,7 +219,7 @@ static Image *ReadEPTImage(const ImageInfo *image_info,ExceptionInfo *exception)
         ept_info.postscript);
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(ept_info.tiff,0,(ept_info.tiff_length+1)*
+  (void) memset(ept_info.tiff,0,(ept_info.tiff_length+1)*
     sizeof(*ept_info.tiff));
   offset=SeekBlob(image,ept_info.tiff_offset,SEEK_SET);
   if ((ept_info.tiff_length != 0) && (offset < 30))
@@ -419,7 +419,7 @@ static MagickBooleanType WriteEPTImage(const ImageInfo *image_info,Image *image,
     (void) CopyMagickString(write_info->magick,"EPS2",MagickPathExtent);
   if (LocaleCompare(image_info->magick,"EPT3") == 0)
     (void) CopyMagickString(write_info->magick,"EPS3",MagickPathExtent);
-  (void) ResetMagickMemory(&ept_info,0,sizeof(ept_info));
+  (void) memset(&ept_info,0,sizeof(ept_info));
   ept_info.magick=0xc6d3d0c5ul;
   ept_info.postscript=(unsigned char *) ImageToBlob(write_info,write_image,
     &ept_info.postscript_length,exception);
diff --git a/coders/exr.c b/coders/exr.c
index 19b2c0cc65c..d905a33940e 100644
--- a/coders/exr.c
+++ b/coders/exr.c
@@ -268,7 +268,7 @@ static Image *ReadEXRImage(const ImageInfo *image_info,ExceptionInfo *exception)
         }
         continue;
       }
-    ResetMagickMemory(scanline,0,columns*sizeof(*scanline));
+    memset(scanline,0,columns*sizeof(*scanline));
     ImfInputSetFrameBuffer(file,scanline-data_window.min_x-columns*yy,1,
       columns);
     ImfInputReadPixels(file,yy,yy);
@@ -576,7 +576,7 @@ static MagickBooleanType WriteEXRImage(const ImageInfo *image_info,Image *image,
       write_info=DestroyImageInfo(write_info);
       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  ResetMagickMemory(scanline,0,image->columns*sizeof(*scanline));
+  memset(scanline,0,image->columns*sizeof(*scanline));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,exception);
diff --git a/coders/fits.c b/coders/fits.c
index 9fc3998d708..51a01469bc6 100644
--- a/coders/fits.c
+++ b/coders/fits.c
@@ -302,7 +302,7 @@ static Image *ReadFITSImage(const ImageInfo *image_info,
   /*
     Initialize image header.
   */
-  (void) ResetMagickMemory(&fits_info,0,sizeof(fits_info));
+  (void) memset(&fits_info,0,sizeof(fits_info));
   fits_info.extend=MagickFalse;
   fits_info.simple=MagickFalse;
   fits_info.bits_per_pixel=8;
@@ -661,7 +661,7 @@ static MagickBooleanType WriteFITSImage(const ImageInfo *image_info,
   fits_info=(char *) AcquireQuantumMemory(FITSBlocksize,sizeof(*fits_info));
   if (fits_info == (char *) NULL)
     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(fits_info,' ',FITSBlocksize*sizeof(*fits_info));
+  (void) memset(fits_info,' ',FITSBlocksize*sizeof(*fits_info));
   /*
     Initialize image header.
   */
@@ -834,7 +834,7 @@ static MagickBooleanType WriteFITSImage(const ImageInfo *image_info,
   length=(size_t) (FITSBlocksize-TellBlob(image) % FITSBlocksize);
   if (length != 0)
     {
-      (void) ResetMagickMemory(fits_info,0,length*sizeof(*fits_info));
+      (void) memset(fits_info,0,length*sizeof(*fits_info));
       (void) WriteBlob(image,length,(unsigned char *) fits_info);
     }
   fits_info=DestroyString(fits_info);
diff --git a/coders/gif.c b/coders/gif.c
index 70d319e32b3..fcee4a93adf 100644
--- a/coders/gif.c
+++ b/coders/gif.c
@@ -211,7 +211,7 @@ static LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)
   lzw_info=(LZWInfo *) AcquireMagickMemory(sizeof(*lzw_info));
   if (lzw_info == (LZWInfo *) NULL)
     return((LZWInfo *) NULL);
-  (void) ResetMagickMemory(lzw_info,0,sizeof(*lzw_info));
+  (void) memset(lzw_info,0,sizeof(*lzw_info));
   lzw_info->image=image;
   lzw_info->data_size=data_size;
   one=1;
@@ -228,9 +228,9 @@ static LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)
       lzw_info=RelinquishLZWInfo(lzw_info);
       return((LZWInfo *) NULL);
     }
-  (void) ResetMagickMemory(lzw_info->table[0],0,MaximumLZWCode*
+  (void) memset(lzw_info->table[0],0,MaximumLZWCode*
     sizeof(**lzw_info->table));
-  (void) ResetMagickMemory(lzw_info->table[1],0,MaximumLZWCode*
+  (void) memset(lzw_info->table[1],0,MaximumLZWCode*
     sizeof(**lzw_info->table));
   for (i=0; i <= (ssize_t) lzw_info->maximum_data_value; i++)
   {
@@ -633,9 +633,9 @@ static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,
   /*
     Initialize GIF encoder.
   */
-  (void) ResetMagickMemory(hash_code,0,MaxHashTable*sizeof(*hash_code));
-  (void) ResetMagickMemory(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));
-  (void) ResetMagickMemory(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));
+  (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));
+  (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));
+  (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));
   number_bits=data_size;
   max_code=MaxCode(number_bits);
   clear_code=((short) one << (data_size-1));
@@ -1023,7 +1023,7 @@ static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if ((count != 6) || ((LocaleNCompare((char *) buffer,"GIF87",5) != 0) &&
       (LocaleNCompare((char *) buffer,"GIF89",5) != 0)))
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
-  (void) ResetMagickMemory(buffer,0,sizeof(buffer));
+  (void) memset(buffer,0,sizeof(buffer));
   meta_image=AcquireImage(image_info,exception);  /* metadata container */
   meta_image->page.width=ReadBlobLSBShort(image);
   meta_image->page.height=ReadBlobLSBShort(image);
@@ -1039,7 +1039,7 @@ static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
       meta_image=DestroyImage(meta_image);
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(global_colormap,0,3*MagickMax(global_colors,256)*
+  (void) memset(global_colormap,0,3*MagickMax(global_colors,256)*
     sizeof(*global_colormap));
   if (BitSet((int) flag,0x80) != 0)
     {
@@ -1168,7 +1168,7 @@ static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
                 if (info == (unsigned char *) NULL)
                   ThrowGIFException(ResourceLimitError,
                     "MemoryAllocationFailed");
-                (void) ResetMagickMemory(info,0,255UL*sizeof(*info));
+                (void) memset(info,0,255UL*sizeof(*info));
                 reserved_length=255;
                 for (info_length=0; ; )
                 {
@@ -1314,7 +1314,7 @@ static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
           MagickMax(local_colors,256),3UL*sizeof(*colormap));
         if (colormap == (unsigned char *) NULL)
           ThrowGIFException(ResourceLimitError,"MemoryAllocationFailed");
-        (void) ResetMagickMemory(colormap,0,3*MagickMax(local_colors,256)*
+        (void) memset(colormap,0,3*MagickMax(local_colors,256)*
           sizeof(*colormap));
         count=ReadBlob(image,(3*local_colors)*sizeof(*colormap),colormap);
         if (count != (ssize_t) (3*local_colors))
diff --git a/coders/hdr.c b/coders/hdr.c
index 74dd24c1181..2ce3869f956 100644
--- a/coders/hdr.c
+++ b/coders/hdr.c
@@ -403,7 +403,7 @@ static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(pixels,0,4*image->columns*sizeof(*pixels));
+  (void) memset(pixels,0,4*image->columns*sizeof(*pixels));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     if (image->compression != RLECompression)
@@ -705,7 +705,7 @@ static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,
   /*
     Write header.
   */
-  (void) ResetMagickMemory(header,' ',MagickPathExtent);
+  (void) memset(header,' ',MagickPathExtent);
   length=CopyMagickString(header,"#?RADIANCE\n",MagickPathExtent);
   (void) WriteBlob(image,length,(unsigned char *) header);
   property=GetImageProperty(image,"comment",exception);
@@ -748,7 +748,7 @@ static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(pixels,0,4*(image->columns+128)*sizeof(*pixels));
+  (void) memset(pixels,0,4*(image->columns+128)*sizeof(*pixels));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,exception);
diff --git a/coders/heic.c b/coders/heic.c
index d7d81b61fcb..8bec54ddb6b 100644
--- a/coders/heic.c
+++ b/coders/heic.c
@@ -452,7 +452,7 @@ static MagickBooleanType ParseIinfAtom(Image *image, DataBuffer *db,
     ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
       image->filename);
 
-  ResetMagickMemory(ctx->itemInfo, 0, sizeof(HEICItemInfo)*(count+1));
+  memset(ctx->itemInfo, 0, sizeof(HEICItemInfo)*(count+1));
 
   for (i = 0; i < count && DBGetSize(db) > 0; i++)
   {
@@ -1088,7 +1088,7 @@ static Image *ReadHEICImage(const ImageInfo *image_info,
   HEICImageContext
     ctx;
 
-  ResetMagickMemory(&ctx, 0, sizeof(ctx));
+  memset(&ctx, 0, sizeof(ctx));
 
   /*
     Open image file.
diff --git a/coders/histogram.c b/coders/histogram.c
index 12d04e5c0bc..ab12e6175d3 100644
--- a/coders/histogram.c
+++ b/coders/histogram.c
@@ -249,7 +249,7 @@ static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,
   /*
     Initialize histogram count arrays.
   */
-  (void) ResetMagickMemory(histogram,0,length*sizeof(*histogram));
+  (void) memset(histogram,0,length*sizeof(*histogram));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,exception);
diff --git a/coders/icon.c b/coders/icon.c
index 2a5d20462dc..d73e0825e6b 100644
--- a/coders/icon.c
+++ b/coders/icon.c
@@ -950,8 +950,8 @@ static MagickBooleanType WriteICONImage(const ImageInfo *image_info,
   (void) WriteBlobLSBShort(image,0);
   (void) WriteBlobLSBShort(image,1);
   (void) WriteBlobLSBShort(image,(unsigned char) scene);
-  (void) ResetMagickMemory(&icon_file,0,sizeof(icon_file));
-  (void) ResetMagickMemory(&icon_info,0,sizeof(icon_info));
+  (void) memset(&icon_file,0,sizeof(icon_file));
+  (void) memset(&icon_info,0,sizeof(icon_info));
   scene=0;
   next=(images != (Image *) NULL) ? images : image;
   do
@@ -1122,7 +1122,7 @@ static MagickBooleanType WriteICONImage(const ImageInfo *image_info,
             images=DestroyImageList(images);
             ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
           }
-        (void) ResetMagickMemory(pixels,0,(size_t) icon_info.image_size);
+        (void) memset(pixels,0,(size_t) icon_info.image_size);
         switch (icon_info.bits_per_pixel)
         {
           case 1:
diff --git a/coders/jnx.c b/coders/jnx.c
index aa003684baf..6ebbad84101 100644
--- a/coders/jnx.c
+++ b/coders/jnx.c
@@ -164,7 +164,7 @@ static Image *ReadJNXImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Read JNX header.
   */
-  (void) ResetMagickMemory(&jnx_info,0,sizeof(jnx_info));
+  (void) memset(&jnx_info,0,sizeof(jnx_info));
   jnx_info.version=ReadBlobLSBSignedLong(image);
   if ((jnx_info.version != 3) && (jnx_info.version != 4))
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
@@ -191,7 +191,7 @@ static Image *ReadJNXImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Read JNX levels.
   */
-  (void) ResetMagickMemory(&jnx_level_info,0,sizeof(jnx_level_info));
+  (void) memset(&jnx_level_info,0,sizeof(jnx_level_info));
   for (i=0; i < (ssize_t) jnx_info.levels; i++)
   {
     jnx_level_info[i].count=ReadBlobLSBSignedLong(image);
diff --git a/coders/jp2.c b/coders/jp2.c
index 5b558b18bac..c159ba32c9d 100644
--- a/coders/jp2.c
+++ b/coders/jp2.c
@@ -945,7 +945,7 @@ static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,
         channels++;
     }
   parameters.tcp_mct=channels == 3 ? 1 : 0;
-  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));
+  memset(jp2_info,0,sizeof(jp2_info));
   for (i=0; i < (ssize_t) channels; i++)
   {
     jp2_info[i].prec=(OPJ_UINT32) image->depth;
diff --git a/coders/jpeg.c b/coders/jpeg.c
index 4ada27ab6c7..5eae6837eab 100644
--- a/coders/jpeg.c
+++ b/coders/jpeg.c
@@ -1107,9 +1107,9 @@ static Image *ReadJPEGImage(const ImageInfo *image_info,
   /*
     Initialize JPEG parameters.
   */
-  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
-  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
-  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
+  (void) memset(&error_manager,0,sizeof(error_manager));
+  (void) memset(&jpeg_info,0,sizeof(jpeg_info));
+  (void) memset(&jpeg_error,0,sizeof(jpeg_error));
   jpeg_info.err=jpeg_std_error(&jpeg_error);
   jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
   jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
@@ -1355,7 +1355,7 @@ static Image *ReadJPEGImage(const ImageInfo *image_info,
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     }
   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
-  (void) ResetMagickMemory(jpeg_pixels,0,image->columns*
+  (void) memset(jpeg_pixels,0,image->columns*
     jpeg_info.output_components*sizeof(*jpeg_pixels));
   /*
     Convert JPEG pixels to pixel packets.
@@ -2209,9 +2209,9 @@ static MagickBooleanType WriteJPEGImage(const ImageInfo *image_info,
   /*
     Initialize JPEG parameters.
   */
-  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
-  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
-  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
+  (void) memset(&error_manager,0,sizeof(error_manager));
+  (void) memset(&jpeg_info,0,sizeof(jpeg_info));
+  (void) memset(&jpeg_error,0,sizeof(jpeg_error));
   volatile_image=image;
   jpeg_info.client_data=(void *) volatile_image;
   jpeg_info.err=jpeg_std_error(&jpeg_error);
diff --git a/coders/json.c b/coders/json.c
index d68ec22d3a9..332b93ee5d8 100644
--- a/coders/json.c
+++ b/coders/json.c
@@ -332,7 +332,7 @@ static ChannelStatistics *GetLocationStatistics(const Image *image,
     MaxPixelChannels+1,sizeof(*channel_statistics));
   if (channel_statistics == (ChannelStatistics *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(channel_statistics,0,(MaxPixelChannels+1)*
+  (void) memset(channel_statistics,0,(MaxPixelChannels+1)*
     sizeof(*channel_statistics));
   for (i=0; i <= (ssize_t) MaxPixelChannels; i++)
   {
diff --git a/coders/mat.c b/coders/mat.c
index ba96f8fc930..7a8f1e5bc9a 100644
--- a/coders/mat.c
+++ b/coders/mat.c
@@ -1202,7 +1202,7 @@ RestoreMSCWarning
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
+    (void) memset(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;
diff --git a/coders/miff.c b/coders/miff.c
index fef3a6a12d5..5cabbfe557e 100644
--- a/coders/miff.c
+++ b/coders/miff.c
@@ -509,7 +509,7 @@ static Image *ReadMIFFImage(const ImageInfo *image_info,
   if (c == EOF)
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
   *id='\0';
-  (void) ResetMagickMemory(keyword,0,sizeof(keyword));
+  (void) memset(keyword,0,sizeof(keyword));
   version=0.0;
   (void) version;
   do
@@ -1335,13 +1335,13 @@ static Image *ReadMIFFImage(const ImageInfo *image_info,
     status=MagickTrue;
     GetPixelInfo(image,&pixel);
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
-   (void) ResetMagickMemory(&bzip_info,0,sizeof(bzip_info));
+   (void) memset(&bzip_info,0,sizeof(bzip_info));
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
-    (void) ResetMagickMemory(&allocator,0,sizeof(allocator));
+    (void) memset(&allocator,0,sizeof(allocator));
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
-    (void) ResetMagickMemory(&zip_info,0,sizeof(zip_info));
+    (void) memset(&zip_info,0,sizeof(zip_info));
 #endif
     switch (image->compression)
     {
@@ -2474,7 +2474,7 @@ static MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,
         int
           code;
 
-        (void) ResetMagickMemory(&bzip_info,0,sizeof(bzip_info));
+        (void) memset(&bzip_info,0,sizeof(bzip_info));
         bzip_info.bzalloc=AcquireBZIPMemory;
         bzip_info.bzfree=RelinquishBZIPMemory;
         code=BZ2_bzCompressInit(&bzip_info,(int) (image->quality ==
@@ -2491,7 +2491,7 @@ static MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,
         int
           code;
 
-        (void) ResetMagickMemory(&allocator,0,sizeof(allocator));
+        (void) memset(&allocator,0,sizeof(allocator));
         allocator.alloc=AcquireLZMAMemory;
         allocator.free=RelinquishLZMAMemory;
         lzma_info=initialize_lzma;
@@ -2509,7 +2509,7 @@ static MagickBooleanType WriteMIFFImage(const ImageInfo *image_info,
         int
           code;
 
-        (void) ResetMagickMemory(&zip_info,0,sizeof(zip_info));
+        (void) memset(&zip_info,0,sizeof(zip_info));
         zip_info.zalloc=AcquireZIPMemory;
         zip_info.zfree=RelinquishZIPMemory;
         code=deflateInit(&zip_info,(int) (image->quality ==
diff --git a/coders/mpc.c b/coders/mpc.c
index 6693a821780..91553f3a241 100644
--- a/coders/mpc.c
+++ b/coders/mpc.c
@@ -213,7 +213,7 @@ static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)
       return((Image *) NULL);
     }
   *id='\0';
-  (void) ResetMagickMemory(keyword,0,sizeof(keyword));
+  (void) memset(keyword,0,sizeof(keyword));
   offset=0;
   do
   {
diff --git a/coders/msl.c b/coders/msl.c
index 7c2be5431ea..2abb365bc8f 100644
--- a/coders/msl.c
+++ b/coders/msl.c
@@ -671,7 +671,7 @@ static void MSLStartElement(void *context,const xmlChar *tag,
   keyword=(const char *) NULL;
   value=(char *) NULL;
   SetGeometryInfo(&geometry_info);
-  (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+  (void) memset(&geometry,0,sizeof(geometry));
   channel=DefaultChannels;
   switch (*tag)
   {
@@ -3072,7 +3072,7 @@ static void MSLStartElement(void *context,const xmlChar *tag,
                 (const char *) tag);
               break;
             }
-          (void) ResetMagickMemory(&frame_info,0,sizeof(frame_info));
+          (void) memset(&frame_info,0,sizeof(frame_info));
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
@@ -6193,7 +6193,7 @@ static void MSLStartElement(void *context,const xmlChar *tag,
                 RectangleInfo
                   geometry;
 
-                (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
+                (void) memset(&geometry,0,sizeof(geometry));
                 image_option=GetImageArtifact(msl_info->image[n],"page");
                 if (image_option != (const char *) NULL)
                   flags=ParseAbsoluteGeometry(image_option,&geometry);
@@ -7830,7 +7830,7 @@ static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,
   /*
     Parse MSL file.
   */
-  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));
+  (void) memset(&msl_info,0,sizeof(msl_info));
   msl_info.exception=exception;
   msl_info.image_info=(ImageInfo **) AcquireMagickMemory(
     sizeof(*msl_info.image_info));
@@ -7856,7 +7856,7 @@ static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,
   if (*image != (Image *) NULL)
     MSLPushImage(&msl_info,*image);
   (void) xmlSubstituteEntitiesDefault(1);
-  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));
+  (void) memset(&sax_modules,0,sizeof(sax_modules));
   sax_modules.internalSubset=MSLInternalSubset;
   sax_modules.isStandalone=MSLIsStandalone;
   sax_modules.hasInternalSubset=MSLHasInternalSubset;
diff --git a/coders/mvg.c b/coders/mvg.c
index fccf361c882..6fa3efac922 100644
--- a/coders/mvg.c
+++ b/coders/mvg.c
@@ -168,7 +168,7 @@ static Image *ReadMVGImage(const ImageInfo *image_info,ExceptionInfo *exception)
       /*
         Determine size of image canvas.
       */
-      (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
+      (void) memset(&bounds,0,sizeof(bounds));
       while (ReadBlobString(image,primitive) != (char *) NULL)
       {
         for (p=primitive; (*p == ' ') || (*p == '\t'); p++) ;
diff --git a/coders/palm.c b/coders/palm.c
index c98c81e072d..9aa1a41feef 100644
--- a/coders/palm.c
+++ b/coders/palm.c
@@ -410,7 +410,7 @@ static Image *ReadPALMImage(const ImageInfo *image_info,
     one_row=(unsigned char *) AcquireQuantumMemory(extent,sizeof(*one_row));
     if (one_row == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-    (void) ResetMagickMemory(one_row,0,extent*sizeof(*one_row));
+    (void) memset(one_row,0,extent*sizeof(*one_row));
     last_row=(unsigned char *) NULL;
     if (compressionType == PALM_COMPRESSION_SCANLINE)
       {
@@ -446,7 +446,7 @@ static Image *ReadPALMImage(const ImageInfo *image_info,
                   break;
                 count=MagickMin(count,(ssize_t) bytes_per_row-i);
                 byte=(size_t) ReadBlobByte(image);
-                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);
+                (void) memset(one_row+i,(int) byte,(size_t) count);
                 i+=count;
               }
           }
@@ -890,7 +890,7 @@ static MagickBooleanType WritePALMImage(const ImageInfo *image_info,
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       ptr=one_row;
-      (void) ResetMagickMemory(ptr,0,bytes_per_row);
+      (void) memset(ptr,0,bytes_per_row);
       p=GetVirtualPixels(image,0,y,image->columns,1,exception);
       if (p == (const Quantum *) NULL)
         break;
diff --git a/coders/pcd.c b/coders/pcd.c
index 7cebfc4d7fd..2f35f0c6545 100644
--- a/coders/pcd.c
+++ b/coders/pcd.c
@@ -617,11 +617,11 @@ static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)
         luma=(unsigned char *) RelinquishMagickMemory(luma);
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(chroma1,0,(image->columns+1UL)*image->rows*
+  (void) memset(chroma1,0,(image->columns+1UL)*image->rows*
     10*sizeof(*chroma1));
-  (void) ResetMagickMemory(chroma2,0,(image->columns+1UL)*image->rows*
+  (void) memset(chroma2,0,(image->columns+1UL)*image->rows*
     10*sizeof(*chroma2));
-  (void) ResetMagickMemory(luma,0,(image->columns+1UL)*image->rows*
+  (void) memset(luma,0,(image->columns+1UL)*image->rows*
     10*sizeof(*luma));
   /*
     Advance to image data.
diff --git a/coders/pcl.c b/coders/pcl.c
index e584e6b94b5..077aef119c7 100644
--- a/coders/pcl.c
+++ b/coders/pcl.c
@@ -244,10 +244,10 @@ static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)
   */
   cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
   count=0;
-  (void) ResetMagickMemory(&bounding_box,0,sizeof(bounding_box));
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
-  (void) ResetMagickMemory(&page,0,sizeof(page));
-  (void) ResetMagickMemory(command,0,sizeof(command));
+  (void) memset(&bounding_box,0,sizeof(bounding_box));
+  (void) memset(&bounds,0,sizeof(bounds));
+  (void) memset(&page,0,sizeof(page));
+  (void) memset(command,0,sizeof(command));
   p=command;
   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
   {
@@ -791,7 +791,7 @@ static MagickBooleanType WritePCLImage(const ImageInfo *image_info,Image *image,
     pixels=(unsigned char *) AcquireQuantumMemory(length+1,sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
-    (void) ResetMagickMemory(pixels,0,(length+1)*sizeof(*pixels));
+    (void) memset(pixels,0,(length+1)*sizeof(*pixels));
     compress_pixels=(unsigned char *) NULL;
     previous_pixels=(unsigned char *) NULL;
 
@@ -815,7 +815,7 @@ static MagickBooleanType WritePCLImage(const ImageInfo *image_info,Image *image,
             pixels=(unsigned char *) RelinquishMagickMemory(pixels);
             ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
           }
-        (void) ResetMagickMemory(compress_pixels,0,(length+256)*
+        (void) memset(compress_pixels,0,(length+256)*
           sizeof(*compress_pixels));
         (void) FormatLocaleString(buffer,MagickPathExtent,"\033*b2M");
         (void) WriteBlobString(image,buffer);
@@ -830,7 +830,7 @@ static MagickBooleanType WritePCLImage(const ImageInfo *image_info,Image *image,
             pixels=(unsigned char *) RelinquishMagickMemory(pixels);
             ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
           }
-        (void) ResetMagickMemory(compress_pixels,0,(3*length+256)*
+        (void) memset(compress_pixels,0,(3*length+256)*
           sizeof(*compress_pixels));
         previous_pixels=(unsigned char *) AcquireQuantumMemory(length+1,
           sizeof(*previous_pixels));
@@ -841,7 +841,7 @@ static MagickBooleanType WritePCLImage(const ImageInfo *image_info,Image *image,
             pixels=(unsigned char *) RelinquishMagickMemory(pixels);
             ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
           }
-        (void) ResetMagickMemory(previous_pixels,0,(length+1)*
+        (void) memset(previous_pixels,0,(length+1)*
           sizeof(*previous_pixels));
         (void) FormatLocaleString(buffer,MagickPathExtent,"\033*b3M");
         (void) WriteBlobString(image,buffer);
diff --git a/coders/pcx.c b/coders/pcx.c
index 41ed1b8f735..a8bce12458d 100644
--- a/coders/pcx.c
+++ b/coders/pcx.c
@@ -417,10 +417,10 @@ static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)
           pixel_info=RelinquishVirtualMemory(pixel_info);
         ThrowPCXException(ResourceLimitError,"MemoryAllocationFailed");
       }
-    (void) ResetMagickMemory(scanline,0,(size_t) MagickMax(image->columns,
+    (void) memset(scanline,0,(size_t) MagickMax(image->columns,
       pcx_info.bytes_per_line)*MagickMax(8,pcx_info.planes)*sizeof(*scanline));
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
-    (void) ResetMagickMemory(pixels,0,(size_t) pcx_packets*(2*sizeof(*pixels)));
+    (void) memset(pixels,0,(size_t) pcx_packets*(2*sizeof(*pixels)));
     /*
       Uncompress image data.
     */
diff --git a/coders/pdb.c b/coders/pdb.c
index 977f1077f7d..effda78fbfa 100644
--- a/coders/pdb.c
+++ b/coders/pdb.c
@@ -330,7 +330,7 @@ static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Determine if this a PDB image file.
   */
-  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));
+  (void) memset(&pdb_info,0,sizeof(pdb_info));
   count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);
   if (count != sizeof(pdb_info.name))
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
@@ -420,7 +420,7 @@ static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)
     sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(pixels,0,(packets+257UL)*image->rows*sizeof(*pixels));
+  (void) memset(pixels,0,(packets+257UL)*image->rows*sizeof(*pixels));
   switch (pdb_image.version & 0x07) 
   {
     case 0:
@@ -787,7 +787,7 @@ static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image,
   } else {
     bits_per_pixel=4;
   }
-  (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info));
+  (void) memset(&pdb_info,0,sizeof(pdb_info));
   (void) CopyMagickString(pdb_info.name,image_info->filename,
     sizeof(pdb_info.name));
   pdb_info.attributes=0;
diff --git a/coders/pdf.c b/coders/pdf.c
index 7869b13956c..ae8f5874c49 100644
--- a/coders/pdf.c
+++ b/coders/pdf.c
@@ -216,7 +216,7 @@ static MagickBooleanType InvokePDFDelegate(const MagickBooleanType verbose,
     ghost_info_struct;
 
   ghost_info=(&ghost_info_struct);
-  (void) ResetMagickMemory(&ghost_info_struct,0,sizeof(ghost_info_struct));
+  (void) memset(&ghost_info_struct,0,sizeof(ghost_info_struct));
   ghost_info_struct.delete_instance=(void (*)(gs_main_instance *))
     gsapi_delete_instance;
   ghost_info_struct.exit=(int (*)(gs_main_instance *)) gsapi_exit;
@@ -500,7 +500,7 @@ static Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)
       if ((flags & SigmaValue) == 0)
         image->resolution.y=image->resolution.x;
     }
-  (void) ResetMagickMemory(&page,0,sizeof(page));
+  (void) memset(&page,0,sizeof(page));
   (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
   if (image_info->page != (char *) NULL)
     (void) ParseAbsoluteGeometry(image_info->page,&page);
@@ -517,10 +517,10 @@ static Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)
   trimbox=IsStringTrue(GetImageOption(image_info,"pdf:use-trimbox"));
   count=0;
   spotcolor=0;
-  (void) ResetMagickMemory(&bounding_box,0,sizeof(bounding_box));
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
-  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));
-  (void) ResetMagickMemory(command,0,sizeof(command));
+  (void) memset(&bounding_box,0,sizeof(bounding_box));
+  (void) memset(&bounds,0,sizeof(bounds));
+  (void) memset(&hires_bounds,0,sizeof(hires_bounds));
+  (void) memset(command,0,sizeof(command));
   angle=0.0;
   p=command;
   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
@@ -1364,7 +1364,7 @@ RestoreMSCWarning
   xref=(MagickOffsetType *) AcquireQuantumMemory(2048UL,sizeof(*xref));
   if (xref == (MagickOffsetType *) NULL)
     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(xref,0,2048UL*sizeof(*xref));
+  (void) memset(xref,0,2048UL*sizeof(*xref));
   /*
     Write Info object.
   */
diff --git a/coders/pict.c b/coders/pict.c
index 9d31486ca00..36125ca9cfc 100644
--- a/coders/pict.c
+++ b/coders/pict.c
@@ -451,7 +451,7 @@ static unsigned char *DecodeImage(Image *blob,Image *image,
   if (pixels == (unsigned char *) NULL)
     return((unsigned char *) NULL);
   *extent=row_bytes*image->rows*sizeof(*pixels);
-  (void) ResetMagickMemory(pixels,0,*extent);
+  (void) memset(pixels,0,*extent);
   scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,2*
     sizeof(*scanline));
   if (scanline == (unsigned char *) NULL)
@@ -459,7 +459,7 @@ static unsigned char *DecodeImage(Image *blob,Image *image,
       pixels=(unsigned char *) RelinquishMagickMemory(pixels);
       return((unsigned char *) NULL);
     }
-  (void) ResetMagickMemory(scanline,0,2*row_bytes*sizeof(*scanline));
+  (void) memset(scanline,0,2*row_bytes*sizeof(*scanline));
   if (bytes_per_line < 8)
     {
       /*
@@ -1782,12 +1782,12 @@ static MagickBooleanType WritePICTImage(const ImageInfo *image_info,
         buffer=(unsigned char *) RelinquishMagickMemory(buffer);
       ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
     }
-  (void) ResetMagickMemory(scanline,0,row_bytes);
-  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));
+  (void) memset(scanline,0,row_bytes);
+  (void) memset(packed_scanline,0,(size_t) (row_bytes+MaxCount));
   /*
     Write header, header size, size bounding box, version, and reserved.
   */
-  (void) ResetMagickMemory(buffer,0,PictInfoSize);
+  (void) memset(buffer,0,PictInfoSize);
   (void) WriteBlob(image,PictInfoSize,buffer);
   (void) WriteBlobMSBShort(image,0);
   (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);
@@ -2020,7 +2020,7 @@ static MagickBooleanType WritePICTImage(const ImageInfo *image_info,
   else
     if (image_info->compression == JPEGCompression)
       {
-        (void) ResetMagickMemory(scanline,0,row_bytes);
+        (void) memset(scanline,0,row_bytes);
         for (y=0; y < (ssize_t) image->rows; y++)
           count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),
             packed_scanline);
diff --git a/coders/png.c b/coders/png.c
index 758e576721f..c5119e233d8 100644
--- a/coders/png.c
+++ b/coders/png.c
@@ -2590,7 +2590,7 @@ static Image *ReadOnePNGImage(MngInfo *mng_info,
     {
       image->rendering_intent=UndefinedIntent;
       intent=Magick_RenderingIntent_to_PNG_RenderingIntent(UndefinedIntent);
-      (void) ResetMagickMemory(&image->chromaticity,0,
+      (void) memset(&image->chromaticity,0,
         sizeof(image->chromaticity));
     }
 
@@ -4247,7 +4247,7 @@ static Image *ReadPNGImage(const ImageInfo *image_info,
   /*
     Initialize members of the MngInfo structure.
   */
-  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));
+  (void) memset(mng_info,0,sizeof(MngInfo));
   mng_info->image=image;
 
   image=ReadOnePNGImage(mng_info,image_info,exception);
@@ -5206,7 +5206,7 @@ static Image *ReadJNGImage(const ImageInfo *image_info,
 
   /* Initialize members of the MngInfo structure.  */
 
-  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));
+  (void) memset(mng_info,0,sizeof(MngInfo));
 
   mng_info->image=image;
   image=ReadOneJNGImage(mng_info,image_info,exception);
@@ -7702,7 +7702,7 @@ static Image *ReadMNGImage(const ImageInfo *image_info,
 
   /* Initialize members of the MngInfo structure.  */
 
-  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));
+  (void) memset(mng_info,0,sizeof(MngInfo));
   mng_info->image=image;
   image=ReadOneMNGImage(mng_info,image_info,exception);
   mng_info=MngInfoFreeStruct(mng_info);
@@ -12047,7 +12047,7 @@ static MagickBooleanType WritePNGImage(const ImageInfo *image_info,
   /*
     Initialize members of the MngInfo structure.
   */
-  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));
+  (void) memset(mng_info,0,sizeof(MngInfo));
   mng_info->image=image;
   mng_info->equal_backgrounds=MagickTrue;
 
@@ -13315,7 +13315,7 @@ static MagickBooleanType WriteJNGImage(const ImageInfo *image_info,
   /*
     Initialize members of the MngInfo structure.
   */
-  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));
+  (void) memset(mng_info,0,sizeof(MngInfo));
   mng_info->image=image;
 
   (void) WriteBlob(image,8,(const unsigned char *) "\213JNG\r\n\032\n");
@@ -13405,7 +13405,7 @@ static MagickBooleanType WriteMNGImage(const ImageInfo *image_info,
   /*
     Initialize members of the MngInfo structure.
   */
-  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));
+  (void) memset(mng_info,0,sizeof(MngInfo));
   mng_info->image=image;
   write_mng=LocaleCompare(image_info->magick,"MNG") == 0;
 
diff --git a/coders/ps.c b/coders/ps.c
index dcd4a5e97ef..b80e8ebd341 100644
--- a/coders/ps.c
+++ b/coders/ps.c
@@ -206,7 +206,7 @@ static MagickBooleanType InvokePostscriptDelegate(
     ghost_info_struct;
 
   ghost_info=(&ghost_info_struct);
-  (void) ResetMagickMemory(&ghost_info_struct,0,sizeof(ghost_info_struct));
+  (void) memset(&ghost_info_struct,0,sizeof(ghost_info_struct));
   ghost_info_struct.delete_instance=(void (*)(gs_main_instance *))
     gsapi_delete_instance;
   ghost_info_struct.exit=(int (*)(gs_main_instance *)) gsapi_exit;
@@ -524,7 +524,7 @@ static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Initialize hex values.
   */
-  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));
+  (void) memset(hex_digits,0,sizeof(hex_digits));
   hex_digits[(int) '0']=0;
   hex_digits[(int) '1']=1;
   hex_digits[(int) '2']=2;
@@ -577,10 +577,10 @@ static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Determine page geometry from the Postscript bounding box.
   */
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
-  (void) ResetMagickMemory(command,0,sizeof(command));
+  (void) memset(&bounds,0,sizeof(bounds));
+  (void) memset(command,0,sizeof(command));
   cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
-  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));
+  (void) memset(&hires_bounds,0,sizeof(hires_bounds));
   columns=0;
   rows=0;
   priority=0;
@@ -1579,7 +1579,7 @@ static MagickBooleanType WritePSImage(const ImageInfo *image_info,Image *image,
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(status);
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
+  (void) memset(&bounds,0,sizeof(bounds));
   compression=image->compression;
   if (image_info->compression != UndefinedCompression)
     compression=image_info->compression;
@@ -1907,7 +1907,7 @@ RestoreMSCWarning
         }
         labels=(char **) RelinquishMagickMemory(labels);
       }
-    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
+    (void) memset(&pixel,0,sizeof(pixel));
     pixel.alpha=(MagickRealType) TransparentAlpha;
     index=0;
     x=0;
diff --git a/coders/ps2.c b/coders/ps2.c
index 5aca717da72..e54e78e195f 100644
--- a/coders/ps2.c
+++ b/coders/ps2.c
@@ -482,7 +482,7 @@ static MagickBooleanType WritePS2Image(const ImageInfo *image_info,Image *image,
     default:
       break;
   }
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
+  (void) memset(&bounds,0,sizeof(bounds));
   page=1;
   scene=0;
   do
diff --git a/coders/ps3.c b/coders/ps3.c
index 49dc1176d3a..1632eb8d73c 100644
--- a/coders/ps3.c
+++ b/coders/ps3.c
@@ -928,7 +928,7 @@ static MagickBooleanType WritePS3Image(const ImageInfo *image_info,Image *image,
     default:
       break;
   }
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
+  (void) memset(&bounds,0,sizeof(bounds));
   page=0;
   scene=0;
   do
diff --git a/coders/psd.c b/coders/psd.c
index 7e8b4885f91..58d22ed618f 100644
--- a/coders/psd.c
+++ b/coders/psd.c
@@ -1177,7 +1177,7 @@ static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,
         image->filename);
     }
 
-  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));
+  (void) memset(compact_pixels,0,length*sizeof(*compact_pixels));
 
   status=MagickTrue;
   for (y=0; y < (ssize_t) image->rows; y++)
@@ -1260,7 +1260,7 @@ static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,
         image->filename);
     }
 
-  ResetMagickMemory(&stream,0,sizeof(stream));
+  memset(&stream,0,sizeof(stream));
   stream.data_type=Z_BINARY;
   stream.next_in=(Bytef *)compact_pixels;
   stream.avail_in=(uInt) compact_size;
@@ -1662,7 +1662,7 @@ static MagickBooleanType ReadPSDLayersInternal(Image *image,
           ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
             image->filename);
         }
-      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
+      (void) memset(layer_info,0,(size_t) number_layers*
         sizeof(*layer_info));
 
       for (i=0; i < number_layers; i++)
@@ -2716,7 +2716,7 @@ static size_t WritePSDChannel(const PSDInfo *psd_info,
           quantum_info=DestroyQuantumInfo(quantum_info);
           return(0);
         }
-      ResetMagickMemory(&stream,0,sizeof(stream));
+      memset(&stream,0,sizeof(stream));
       stream.data_type=Z_BINARY;
       level=Z_DEFAULT_COMPRESSION;
       if ((image_info->quality > 0 && image_info->quality < 10))
diff --git a/coders/pwp.c b/coders/pwp.c
index 89e7a219448..fca3765888d 100644
--- a/coders/pwp.c
+++ b/coders/pwp.c
@@ -173,7 +173,7 @@ static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)
   status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     return((Image *) NULL);
-  ResetMagickMemory(magick,0,sizeof(magick));
+  memset(magick,0,sizeof(magick));
   count=ReadBlob(pwp_image,5,magick);
   if ((count != 5) || (LocaleNCompare((char *) magick,"SFW95",5) != 0))
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
diff --git a/coders/rla.c b/coders/rla.c
index b2cce34bef3..2c319530688 100644
--- a/coders/rla.c
+++ b/coders/rla.c
@@ -204,7 +204,7 @@ static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
-  (void) ResetMagickMemory(&rla_info,0,sizeof(rla_info));
+  (void) memset(&rla_info,0,sizeof(rla_info));
   rla_info.window.left=(short) ReadBlobMSBShort(image);
   rla_info.window.right=(short) ReadBlobMSBShort(image);
   rla_info.window.bottom=(short) ReadBlobMSBShort(image);
diff --git a/coders/rle.c b/coders/rle.c
index 9e875dd8ea9..54a34219106 100644
--- a/coders/rle.c
+++ b/coders/rle.c
@@ -351,7 +351,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
     pixel_info_length=image->columns*image->rows*
       MagickMax(number_planes_filled,4);
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
-    (void) ResetMagickMemory(pixels,0,pixel_info_length);
+    (void) memset(pixels,0,pixel_info_length);
     if ((flags & 0x01) && !(flags & 0x02))
       {
         ssize_t
diff --git a/coders/screenshot.c b/coders/screenshot.c
index 2fb9149e188..520455bc7d8 100644
--- a/coders/screenshot.c
+++ b/coders/screenshot.c
@@ -179,7 +179,7 @@ static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,
           DeleteDC(hDC);
           ThrowReaderException(CoderError,"UnableToCreateDC");
         }
-      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));
+      (void) memset(&bmi,0,sizeof(BITMAPINFO));
       bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
       bmi.bmiHeader.biWidth=(LONG) screen->columns;
       bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;
diff --git a/coders/sct.c b/coders/sct.c
index a79536e1f0b..4f980f3b1af 100644
--- a/coders/sct.c
+++ b/coders/sct.c
@@ -179,8 +179,8 @@ static Image *ReadSCTImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Read control block.
   */
-  ResetMagickMemory(magick,0,sizeof(magick));
-  ResetMagickMemory(buffer,0,sizeof(buffer));
+  memset(magick,0,sizeof(magick));
+  memset(buffer,0,sizeof(buffer));
   count=ReadBlob(image,80,buffer);
   (void) count;
   count=ReadBlob(image,2,(unsigned char *) magick);
diff --git a/coders/sgi.c b/coders/sgi.c
index 807848d4535..a17f7f9a2e0 100644
--- a/coders/sgi.c
+++ b/coders/sgi.c
@@ -312,7 +312,7 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Read SGI raster header.
   */
-  (void) ResetMagickMemory(&iris_info,0,sizeof(iris_info));
+  (void) memset(&iris_info,0,sizeof(iris_info));
   iris_info.magic=ReadBlobMSBShort(image);
   do
   {
@@ -389,7 +389,7 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
-    (void) ResetMagickMemory(pixels,0,iris_info.columns*iris_info.rows*4*
+    (void) memset(pixels,0,iris_info.columns*iris_info.rows*4*
       bytes_per_pixel*sizeof(*pixels));
     if ((int) iris_info.storage != 0x01)
       {
@@ -953,7 +953,7 @@ static MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,
       Initialize SGI raster file header.
     */
     (void) TransformImageColorspace(image,sRGBColorspace,exception);
-    (void) ResetMagickMemory(&iris_info,0,sizeof(iris_info));
+    (void) memset(&iris_info,0,sizeof(iris_info));
     iris_info.magic=0x01DA;
     compression=image->compression;
     if (image_info->compression != UndefinedCompression)
diff --git a/coders/sixel.c b/coders/sixel.c
index c2870f572ce..417a011c3e5 100644
--- a/coders/sixel.c
+++ b/coders/sixel.c
@@ -290,7 +290,7 @@ MagickBooleanType sixel_decode(Image *image,
         sixel_palet[n] = SIXEL_RGB(255, 255, 255);
     }
 
-    (void) ResetMagickMemory(imbuf, background_color_index, (size_t) imsx * imsy);
+    (void) memset(imbuf, background_color_index, (size_t) imsx * imsy);
 
     while (*p != '\0') {
         if ((p[0] == '\033' && p[1] == 'P') || *p == 0x90) {
@@ -371,7 +371,7 @@ MagickBooleanType sixel_decode(Image *image,
                     imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                     return (MagickFalse);
                 }
-                (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);
+                (void) memset(dmbuf, background_color_index, (size_t) dmsx * dmsy);
                 for (y = 0; y < imsy; ++y) {
                     (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);
                 }
@@ -449,7 +449,7 @@ MagickBooleanType sixel_decode(Image *image,
                     imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                     return (MagickFalse);
                 }
-                (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);
+                (void) memset(dmbuf, background_color_index, (size_t) dmsx * dmsy);
                 for (y = 0; y < imsy; ++y) {
                     (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);
                 }
@@ -506,7 +506,7 @@ MagickBooleanType sixel_decode(Image *image,
                                     imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);
                                     return (MagickFalse);
                                   }
-                                (void) ResetMagickMemory(imbuf + offset, color_index, repeat_count);
+                                (void) memset(imbuf + offset, color_index, repeat_count);
                             }
                             if (max_x < (posision_x + repeat_count - 1)) {
                                 max_x = posision_x + repeat_count - 1;
@@ -735,7 +735,7 @@ static MagickBooleanType sixel_encode_impl(unsigned char *pixels, size_t width,s
     if ((map = (unsigned char *)AcquireQuantumMemory(len, sizeof(unsigned char))) == NULL) {
         return (MagickFalse);
     }
-    (void) ResetMagickMemory(map, 0, len);
+    (void) memset(map, 0, len);
 
     if (context->has_8bit_control) {
         nwrite = sprintf((char *)context->buffer, "\x90" "0;0;0" "q");
@@ -875,7 +875,7 @@ static MagickBooleanType sixel_encode_impl(unsigned char *pixels, size_t width,s
         }
 
         i = 0;
-        (void) ResetMagickMemory(map, 0, len);
+        (void) memset(map, 0, len);
     }
 
     if (context->has_8bit_control) {
diff --git a/coders/sun.c b/coders/sun.c
index f6a749f8d96..1a557c72de9 100644
--- a/coders/sun.c
+++ b/coders/sun.c
@@ -297,7 +297,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
   /*
     Read SUN raster header.
   */
-  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
+  (void) memset(&sun_info,0,sizeof(sun_info));
   sun_info.magic=ReadBlobMSBLong(image);
   do
   {
@@ -478,7 +478,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
         sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
         ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
       }
-    (void) ResetMagickMemory(sun_pixels,0,(pixels_length+image->rows)*
+    (void) memset(sun_pixels,0,(pixels_length+image->rows)*
       sizeof(*sun_pixels));
     if (sun_info.type == RT_ENCODED)
       {
diff --git a/coders/svg.c b/coders/svg.c
index 17a258b15d3..5f1b61b3ddd 100644
--- a/coders/svg.c
+++ b/coders/svg.c
@@ -265,7 +265,7 @@ static SVGInfo *AcquireSVGInfo(void)
   svg_info=(SVGInfo *) AcquireMagickMemory(sizeof(*svg_info));
   if (svg_info == (SVGInfo *) NULL)
     return((SVGInfo *) NULL);
-  (void) ResetMagickMemory(svg_info,0,sizeof(*svg_info));
+  (void) memset(svg_info,0,sizeof(*svg_info));
   svg_info->text=AcquireString("");
   svg_info->scale=(double *) AcquireCriticalMemory(sizeof(*svg_info->scale));
   GetAffineMatrix(&svg_info->affine);
@@ -2541,8 +2541,8 @@ static void SVGEndElement(void *context,const xmlChar *name)
       break;
   }
   *svg_info->text='\0';
-  (void) ResetMagickMemory(&svg_info->element,0,sizeof(svg_info->element));
-  (void) ResetMagickMemory(&svg_info->segment,0,sizeof(svg_info->segment));
+  (void) memset(&svg_info->element,0,sizeof(svg_info->element));
+  (void) memset(&svg_info->segment,0,sizeof(svg_info->segment));
   svg_info->n--;
 }
 
@@ -3232,7 +3232,7 @@ static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),"begin SAX");
   (void) xmlSubstituteEntitiesDefault(1);
-  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));
+  (void) memset(&sax_modules,0,sizeof(sax_modules));
   sax_modules.internalSubset=SVGInternalSubset;
   sax_modules.isStandalone=SVGIsStandalone;
   sax_modules.hasInternalSubset=SVGHasInternalSubset;
diff --git a/coders/tga.c b/coders/tga.c
index daadbd05673..d4ba27c8a5d 100644
--- a/coders/tga.c
+++ b/coders/tga.c
@@ -323,7 +323,7 @@ static Image *ReadTGAImage(const ImageInfo *image_info,
   status=SetImageExtent(image,image->columns,image->rows,exception);
   if (status == MagickFalse)
     return(DestroyImageList(image));
-  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));
+  (void) memset(&pixel,0,sizeof(pixel));
   pixel.alpha=(MagickRealType) OpaqueAlpha;
   if (tga_info.colormap_type != 0)
     {
diff --git a/coders/tiff.c b/coders/tiff.c
index 8179c244a62..e194736d91c 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -2348,7 +2348,7 @@ static void TIFFIgnoreTags(TIFF *tiff)
   if (ignore == (TIFFFieldInfo *) NULL)
     return;
   /* This also sets field_bit to 0 (FIELD_IGNORE) */
-  ResetMagickMemory(ignore,0,count*sizeof(*ignore));
+  memset(ignore,0,count*sizeof(*ignore));
   while (*p != '\0')
   {
     while ((isspace((int) ((unsigned char) *p)) != 0))
@@ -2934,7 +2934,7 @@ static MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,
     tile_rows;
 
   assert(tiff_info != (TIFFInfo *) NULL);
-  (void) ResetMagickMemory(tiff_info,0,sizeof(*tiff_info));
+  (void) memset(tiff_info,0,sizeof(*tiff_info));
   option=GetImageOption(image_info,"tiff:tile-geometry");
   if (option == (const char *) NULL)
     {
@@ -4154,9 +4154,9 @@ RestoreMSCWarning
         /*
           Initialize TIFF colormap.
         */
-        (void) ResetMagickMemory(red,0,65536*sizeof(*red));
-        (void) ResetMagickMemory(green,0,65536*sizeof(*green));
-        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));
+        (void) memset(red,0,65536*sizeof(*red));
+        (void) memset(green,0,65536*sizeof(*green));
+        (void) memset(blue,0,65536*sizeof(*blue));
         for (i=0; i < (ssize_t) image->colors; i++)
         {
           red[i]=ScaleQuantumToShort(image->colormap[i].red);
diff --git a/coders/txt.c b/coders/txt.c
index 80cdf7af854..e03d45e7088 100644
--- a/coders/txt.c
+++ b/coders/txt.c
@@ -204,7 +204,7 @@ static Image *ReadTEXTImage(const ImageInfo *image_info,
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
-  (void) ResetMagickMemory(text,0,sizeof(text));
+  (void) memset(text,0,sizeof(text));
   (void) ReadBlobString(image,text);
   /*
     Set the page geometry.
@@ -433,7 +433,7 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
-  (void) ResetMagickMemory(text,0,sizeof(text));
+  (void) memset(text,0,sizeof(text));
   (void) ReadBlobString(image,text);
   if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
diff --git a/coders/uyvy.c b/coders/uyvy.c
index d9e71e25157..73c1e0d4499 100644
--- a/coders/uyvy.c
+++ b/coders/uyvy.c
@@ -331,7 +331,7 @@ static MagickBooleanType WriteUYVYImage(const ImageInfo *image_info,
     return(MagickFalse);
   (void) TransformImageColorspace(uyvy_image,YCbCrColorspace,exception);
   full=MagickFalse;
-  (void) ResetMagickMemory(&pixel,0,sizeof(PixelInfo));
+  (void) memset(&pixel,0,sizeof(PixelInfo));
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(uyvy_image,0,y,image->columns,1,exception);
diff --git a/coders/vicar.c b/coders/vicar.c
index 57136e02ad5..f81ed3edd0c 100644
--- a/coders/vicar.c
+++ b/coders/vicar.c
@@ -466,7 +466,7 @@ static MagickBooleanType WriteVICARImage(const ImageInfo *image_info,
   /*
     Write header.
   */
-  (void) ResetMagickMemory(header,' ',MagickPathExtent);
+  (void) memset(header,' ',MagickPathExtent);
   (void) FormatLocaleString(header,MagickPathExtent,
     "LBLSIZE=%.20g FORMAT='BYTE' TYPE='IMAGE' BUFSIZE=20000 DIM=2 EOL=0 "
     "RECSIZE=%.20g ORG='BSQ' NL=%.20g NS=%.20g NB=1 N1=0 N2=0 N3=0 N4=0 NBB=0 "
diff --git a/coders/viff.c b/coders/viff.c
index 1666df069f9..aae1a2ad775 100644
--- a/coders/viff.c
+++ b/coders/viff.c
@@ -519,7 +519,7 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,
       number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));
     if (pixels == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-    (void) ResetMagickMemory(pixels,0,MagickMax(number_pixels,max_packets)*
+    (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*
       bytes_per_pixel*sizeof(*pixels));
     count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
     lsb_first=1;
@@ -974,7 +974,7 @@ static MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);
   if (status == MagickFalse)
     return(status);
-  (void) ResetMagickMemory(&viff_info,0,sizeof(ViffInfo));
+  (void) memset(&viff_info,0,sizeof(ViffInfo));
   scene=0;
   do
   {
diff --git a/coders/wmf.c b/coders/wmf.c
index 84e4f9a1613..fad57063680 100644
--- a/coders/wmf.c
+++ b/coders/wmf.c
@@ -1425,7 +1425,7 @@ static void ipa_functions(wmfAPI *API)
   if (ERR(API))
     return;
 
-  (void) ResetMagickMemory((void *) ddata, 0, sizeof(wmf_magick_t));
+  (void) memset((void *) ddata, 0, sizeof(wmf_magick_t));
   API->device_data = (void *) ddata;
 
   /*
@@ -2607,7 +2607,7 @@ static Image *ReadWMFImage(const ImageInfo *image_info,ExceptionInfo *exception)
 
   /* Register callbacks */
   wmf_options_flags |= WMF_OPT_FUNCTION;
-  (void) ResetMagickMemory(&wmf_api_options, 0, sizeof(wmf_api_options));
+  (void) memset(&wmf_api_options, 0, sizeof(wmf_api_options));
   wmf_api_options.function = ipa_functions;
 
   /* Ignore non-fatal errors */
diff --git a/coders/wpg.c b/coders/wpg.c
index 7e25a52b321..ec1cfeb8c89 100644
--- a/coders/wpg.c
+++ b/coders/wpg.c
@@ -446,7 +446,7 @@ static int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)
   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,
     8*sizeof(*BImgBuff));
   if(BImgBuff==NULL) return(-2);
-  (void) ResetMagickMemory(BImgBuff,0,(size_t) ldblk*8*sizeof(*BImgBuff));
+  (void) memset(BImgBuff,0,(size_t) ldblk*8*sizeof(*BImgBuff));
 
   while(y<(ssize_t) image->rows)
     {
@@ -565,7 +565,7 @@ static int UnpackWPG2Raster(Image *image,int bpp,ExceptionInfo *exception)
     sizeof(*BImgBuff));
   if(BImgBuff==NULL)
     return(-2);
-  (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(*BImgBuff));
+  (void) memset(BImgBuff,0,ldblk*sizeof(*BImgBuff));
 
   while( y< image->rows)
     {
diff --git a/coders/xcf.c b/coders/xcf.c
index c29b1fff06e..f10d6d240ac 100644
--- a/coders/xcf.c
+++ b/coders/xcf.c
@@ -805,7 +805,7 @@ static MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,
     layer_mask_offset;
 
   /* clear the block! */
-  (void) ResetMagickMemory( outLayer, 0, sizeof( XCFLayerInfo ) );
+  (void) memset( outLayer, 0, sizeof( XCFLayerInfo ) );
   /* read in the layer width, height, type and name */
   outLayer->width = ReadBlobMSBLong(image);
   outLayer->height = ReadBlobMSBLong(image);
@@ -1079,7 +1079,7 @@ static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
   if ((count != 14) ||
       (LocaleNCompare((char *) magick,"gimp xcf",8) != 0))
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
-  (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));
+  (void) memset(&doc_info,0,sizeof(XCFDocInfo));
   doc_info.width=ReadBlobMSBLong(image);
   doc_info.height=ReadBlobMSBLong(image);
   if ((doc_info.width > 262144) || (doc_info.height > 262144))
@@ -1333,7 +1333,7 @@ static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
       sizeof(*layer_info));
     if (layer_info == (XCFLayerInfo *) NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
-    (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));
+    (void) memset(layer_info,0,number_layers*sizeof(XCFLayerInfo));
     for ( ; ; )
     {
       MagickBooleanType
diff --git a/coders/xps.c b/coders/xps.c
index 5a2e5bcaaad..1d7dfe16e66 100644
--- a/coders/xps.c
+++ b/coders/xps.c
@@ -198,10 +198,10 @@ static Image *ReadXPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
   */
   cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
   count=0;
-  (void) ResetMagickMemory(&bounding_box,0,sizeof(bounding_box));
-  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));
-  (void) ResetMagickMemory(&page,0,sizeof(page));
-  (void) ResetMagickMemory(command,0,sizeof(command));
+  (void) memset(&bounding_box,0,sizeof(bounding_box));
+  (void) memset(&bounds,0,sizeof(bounds));
+  (void) memset(&page,0,sizeof(page));
+  (void) memset(command,0,sizeof(command));
   p=command;
   for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
   {
diff --git a/coders/xwd.c b/coders/xwd.c
index 0190e69a03c..5aba8557ccd 100644
--- a/coders/xwd.c
+++ b/coders/xwd.c
@@ -737,7 +737,7 @@ static MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image,
   /*
     Initialize XWD file header.
   */
-  (void) ResetMagickMemory(&xwd_info,0,sizeof(xwd_info));
+  (void) memset(&xwd_info,0,sizeof(xwd_info));
   xwd_info.header_size=(CARD32) sz_XWDheader;
   value=GetImageProperty(image,"comment",exception);
   if (value != (const char *) NULL)
@@ -800,7 +800,7 @@ static MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image,
       /*
         Dump colormap to file.
       */
-      (void) ResetMagickMemory(&color,0,sizeof(color));
+      (void) memset(&color,0,sizeof(color));
       colors=(XColor *) AcquireQuantumMemory((size_t) image->colors,
         sizeof(*colors));
       if (colors == (XColor *) NULL)
@@ -844,7 +844,7 @@ static MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image,
   pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));
   if (pixels == (unsigned char *) NULL)
     ThrowWriterException(ResourceLimitError,"MemoryAllocationFailed");
-  (void) ResetMagickMemory(pixels,0,length);
+  (void) memset(pixels,0,length);
   /*
     Convert MIFF to XWD raster pixels.
   */
diff --git a/tests/validate.c b/tests/validate.c
index 336fce49353..abd74b5a62a 100644
--- a/tests/validate.c
+++ b/tests/validate.c
@@ -2108,7 +2108,7 @@ static size_t ValidateImportExportPixels(ImageInfo *image_info,
           reference_image=DestroyImage(reference_image);
           continue;
         }
-      (void) ResetMagickMemory(pixels,0,length*sizeof(*pixels));
+      (void) memset(pixels,0,length*sizeof(*pixels));
       status=ExportImagePixels(reference_image,0,0,reference_image->columns,
         reference_image->rows,reference_map[i],reference_storage[j].type,pixels,
         exception);
diff --git a/tests/wandtest.c b/tests/wandtest.c
index 2ef07bf6c09..a9e00880099 100644
--- a/tests/wandtest.c
+++ b/tests/wandtest.c
@@ -5341,7 +5341,7 @@ int main(int argc,char **argv)
       primary_colors);
     if (status == MagickFalse)
       ThrowAPIException(magick_wand);
-    ResetMagickMemory(pixels,0,sizeof(pixels));
+    memset(pixels,0,sizeof(pixels));
     status=MagickExportImagePixels(magick_wand,10,10,3,3,"RGB",CharPixel,
       pixels);
     if (status == MagickFalse)
