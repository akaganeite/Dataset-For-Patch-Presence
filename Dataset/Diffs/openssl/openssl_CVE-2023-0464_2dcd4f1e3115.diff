diff --git a/crypto/x509v3/pcy_int.h b/crypto/x509v3/pcy_int.h
index b5075f9edbdd91..0ed2349d673fc2 100644
--- a/crypto/x509v3/pcy_int.h
+++ b/crypto/x509v3/pcy_int.h
@@ -161,6 +161,11 @@ struct X509_POLICY_LEVEL_st {
 };
 
 struct X509_POLICY_TREE_st {
+    /* The number of nodes in the tree */
+    size_t node_count;
+    /* The maximum number of nodes in the tree */
+    size_t node_maximum;
+
     /* This is the tree 'level' data */
     X509_POLICY_LEVEL *levels;
     int nlevel;
@@ -209,7 +214,8 @@ X509_POLICY_NODE *tree_find_sk(STACK_OF(X509_POLICY_NODE) *sk,
 X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
                                  const X509_POLICY_DATA *data,
                                  X509_POLICY_NODE *parent,
-                                 X509_POLICY_TREE *tree);
+                                 X509_POLICY_TREE *tree,
+                                 int extra_data);
 void policy_node_free(X509_POLICY_NODE *node);
 int policy_node_match(const X509_POLICY_LEVEL *lvl,
                       const X509_POLICY_NODE *node, const ASN1_OBJECT *oid);
diff --git a/crypto/x509v3/pcy_node.c b/crypto/x509v3/pcy_node.c
index d6c917650aa442..214b8dff190789 100644
--- a/crypto/x509v3/pcy_node.c
+++ b/crypto/x509v3/pcy_node.c
@@ -111,9 +111,15 @@ X509_POLICY_NODE *level_find_node(const X509_POLICY_LEVEL *level,
 X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
                                  const X509_POLICY_DATA *data,
                                  X509_POLICY_NODE *parent,
-                                 X509_POLICY_TREE *tree)
+                                 X509_POLICY_TREE *tree,
+                                 int extra_data)
 {
     X509_POLICY_NODE *node;
+
+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */
+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)
+        return NULL;
+
     node = OPENSSL_malloc(sizeof(X509_POLICY_NODE));
     if (!node)
         return NULL;
@@ -136,7 +142,7 @@ X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
         }
     }
 
-    if (tree) {
+    if (extra_data) {
         if (!tree->extra_data)
             tree->extra_data = sk_X509_POLICY_DATA_new_null();
         if (!tree->extra_data)
@@ -145,6 +151,7 @@ X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
             goto node_error;
     }
 
+    tree->node_count++;
     if (parent)
         parent->nchild++;
 
diff --git a/crypto/x509v3/pcy_tree.c b/crypto/x509v3/pcy_tree.c
index 03c9533bcca90e..efabe0d302c766 100644
--- a/crypto/x509v3/pcy_tree.c
+++ b/crypto/x509v3/pcy_tree.c
@@ -63,6 +63,18 @@
 
 #include "pcy_int.h"
 
+/*
+ * If the maximum number of nodes in the policy tree isn't defined, set it to
+ * a generous default of 1000 nodes.
+ *
+ * Defining this to be zero means unlimited policy tree growth which opens the
+ * door on CVE-2023-0464.
+ */
+
+#ifndef OPENSSL_POLICY_TREE_NODES_MAX
+# define OPENSSL_POLICY_TREE_NODES_MAX 1000
+#endif
+
 /*
  * Enable this to print out the complete policy tree at various point during
  * evaluation.
@@ -225,6 +237,10 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,
     if (!tree)
         return 0;
 
+    /* Limit the growth of the tree to mitigate CVE-2023-0464 */
+    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;
+    tree->node_count = 0;
+
     tree->flags = 0;
     tree->levels = OPENSSL_malloc(sizeof(X509_POLICY_LEVEL) * n);
     tree->nlevel = 0;
@@ -247,7 +263,7 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,
 
     data = policy_data_new(NULL, OBJ_nid2obj(NID_any_policy), 0);
 
-    if (!data || !level_add_node(level, data, NULL, tree))
+    if (!data || !level_add_node(level, data, NULL, tree, 1))
         goto bad_tree;
 
     for (i = n - 2; i >= 0; i--) {
@@ -304,7 +320,8 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,
 }
 
 static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,
-                                    const X509_POLICY_DATA *data)
+                                    const X509_POLICY_DATA *data,
+                                    X509_POLICY_TREE *tree)
 {
     X509_POLICY_LEVEL *last = curr - 1;
     X509_POLICY_NODE *node;
@@ -313,13 +330,13 @@ static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,
     for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {
         node = sk_X509_POLICY_NODE_value(last->nodes, i);
         if (policy_node_match(last, node, data->valid_policy)) {
-            if (!level_add_node(curr, data, node, NULL))
+            if (level_add_node(curr, data, node, tree, 0) == NULL)
                 return 0;
             matched = 1;
         }
     }
     if (!matched && last->anyPolicy) {
-        if (!level_add_node(curr, data, last->anyPolicy, NULL))
+        if (level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)
             return 0;
     }
     return 1;
@@ -331,7 +348,8 @@ static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,
  */
 
 static int tree_link_nodes(X509_POLICY_LEVEL *curr,
-                           const X509_POLICY_CACHE *cache)
+                           const X509_POLICY_CACHE *cache,
+                           X509_POLICY_TREE *tree)
 {
     int i;
     X509_POLICY_DATA *data;
@@ -352,7 +370,7 @@ static int tree_link_nodes(X509_POLICY_LEVEL *curr,
             continue;
 #endif
         /* Look for matching nodes in previous level */
-        if (!tree_link_matching_nodes(curr, data))
+        if (!tree_link_matching_nodes(curr, data, tree))
             return 0;
     }
     return 1;
@@ -382,7 +400,7 @@ static int tree_add_unmatched(X509_POLICY_LEVEL *curr,
     /* Curr may not have anyPolicy */
     data->qualifier_set = cache->anyPolicy->qualifier_set;
     data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;
-    if (!level_add_node(curr, data, node, tree)) {
+    if (level_add_node(curr, data, node, tree, 1) == NULL) {
         policy_data_free(data);
         return 0;
     }
@@ -464,7 +482,7 @@ static int tree_link_any(X509_POLICY_LEVEL *curr,
         /* Curr may not have anyPolicy */
         data->qualifier_set = cache->anyPolicy->qualifier_set;
         data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;
-        if (!level_add_node(curr, data, node, tree)) {
+        if (!level_add_node(curr, data, node, tree, 1)) {
             policy_data_free(data);
             return 0;
         }
@@ -472,10 +490,9 @@ static int tree_link_any(X509_POLICY_LEVEL *curr,
 
     }
     /* Finally add link to anyPolicy */
-    if (last->anyPolicy) {
-        if (!level_add_node(curr, cache->anyPolicy, last->anyPolicy, NULL))
-            return 0;
-    }
+    if (last->anyPolicy &&
+        level_add_node(curr, cache->anyPolicy, last->anyPolicy, tree, 0) == NULL)
+        return 0;
     return 1;
 }
 
@@ -646,7 +663,7 @@ static int tree_calculate_user_set(X509_POLICY_TREE *tree,
             extra->qualifier_set = anyPolicy->data->qualifier_set;
             extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS
                 | POLICY_DATA_FLAG_EXTRA_NODE;
-            node = level_add_node(NULL, extra, anyPolicy->parent, tree);
+            node = level_add_node(NULL, extra, anyPolicy->parent, tree, 1);
         }
         if (!tree->user_policies) {
             tree->user_policies = sk_X509_POLICY_NODE_new_null();
@@ -668,7 +685,7 @@ static int tree_evaluate(X509_POLICY_TREE *tree)
 
     for (i = 1; i < tree->nlevel; i++, curr++) {
         cache = policy_cache_set(curr->cert);
-        if (!tree_link_nodes(curr, cache))
+        if (!tree_link_nodes(curr, cache, tree))
             return 0;
 
         if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)
